// autogenerated

// swiftlint:disable all
import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension V1.SubscriptionGroups.ById.Subscriptions {
    public struct GET: Endpoint {
        public typealias Response = SubscriptionsResponse

        public var path: String {
            "/v1/subscriptionGroups/\(id)/subscriptions"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[promotedPurchases]",
                             value: parameters.fields[.promotedPurchases]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptionAppStoreReviewScreenshots]",
                             value: parameters.fields[.subscriptionAppStoreReviewScreenshots]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptionAvailabilities]",
                             value: parameters.fields[.subscriptionAvailabilities]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptionGroups]",
                             value: parameters.fields[.subscriptionGroups]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptionIntroductoryOffers]",
                             value: parameters.fields[.subscriptionIntroductoryOffers]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptionLocalizations]",
                             value: parameters.fields[.subscriptionLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptionOfferCodes]",
                             value: parameters.fields[.subscriptionOfferCodes]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptionPrices]",
                             value: parameters.fields[.subscriptionPrices]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptionPromotionalOffers]",
                             value: parameters.fields[.subscriptionPromotionalOffers]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[subscriptions]",
                             value: parameters.fields[.subscriptions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[name]",
                             value: parameters.filter[.name]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[productId]",
                             value: parameters.filter[.productId]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[state]",
                             value: parameters.filter[.state]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[introductoryOffers]",
                             value: parameters.limit[.introductoryOffers].map { "\($0)" }),
                URLQueryItem(name: "limit[offerCodes]",
                             value: parameters.limit[.offerCodes].map { "\($0)" }),
                URLQueryItem(name: "limit[prices]",
                             value: parameters.limit[.prices].map { "\($0)" }),
                URLQueryItem(name: "limit[promotionalOffers]",
                             value: parameters.limit[.promotionalOffers].map { "\($0)" }),
                URLQueryItem(name: "limit[subscriptionLocalizations]",
                             value: parameters.limit[.subscriptionLocalizations].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" }),
                URLQueryItem(name: "sort",
                             value: parameters.sort?.map { "\($0)" }.joined(separator: ","))
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of Subscriptions as `SubscriptionsResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(SubscriptionsResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.SubscriptionGroups.ById.Subscriptions.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        /// comma-separated list of sort expressions; resources will be sorted as specified
        public var sort: [Sort]?

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum PromotedPurchases: Hashable, Codable, RawRepresentable {
                case app
                case enabled
                case inAppPurchaseV2
                case promotionImages
                case state
                case subscription
                case visibleForAllUsers
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .enabled: return "enabled"
                    case .inAppPurchaseV2: return "inAppPurchaseV2"
                    case .promotionImages: return "promotionImages"
                    case .state: return "state"
                    case .subscription: return "subscription"
                    case .visibleForAllUsers: return "visibleForAllUsers"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "enabled": self = .enabled
                    case "inAppPurchaseV2": self = .inAppPurchaseV2
                    case "promotionImages": self = .promotionImages
                    case "state": self = .state
                    case "subscription": self = .subscription
                    case "visibleForAllUsers": self = .visibleForAllUsers
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum SubscriptionAppStoreReviewScreenshots: Hashable, Codable, RawRepresentable {
                case assetDeliveryState
                case assetToken
                case assetType
                case fileName
                case fileSize
                case imageAsset
                case sourceFileChecksum
                case subscription
                case uploadOperations
                case uploaded
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .assetDeliveryState: return "assetDeliveryState"
                    case .assetToken: return "assetToken"
                    case .assetType: return "assetType"
                    case .fileName: return "fileName"
                    case .fileSize: return "fileSize"
                    case .imageAsset: return "imageAsset"
                    case .sourceFileChecksum: return "sourceFileChecksum"
                    case .subscription: return "subscription"
                    case .uploadOperations: return "uploadOperations"
                    case .uploaded: return "uploaded"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "assetDeliveryState": self = .assetDeliveryState
                    case "assetToken": self = .assetToken
                    case "assetType": self = .assetType
                    case "fileName": self = .fileName
                    case "fileSize": self = .fileSize
                    case "imageAsset": self = .imageAsset
                    case "sourceFileChecksum": self = .sourceFileChecksum
                    case "subscription": self = .subscription
                    case "uploadOperations": self = .uploadOperations
                    case "uploaded": self = .uploaded
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum SubscriptionAvailabilities: Hashable, Codable, RawRepresentable {
                case availableInNewTerritories
                case availableTerritories
                case subscription
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .availableInNewTerritories: return "availableInNewTerritories"
                    case .availableTerritories: return "availableTerritories"
                    case .subscription: return "subscription"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "availableInNewTerritories": self = .availableInNewTerritories
                    case "availableTerritories": self = .availableTerritories
                    case "subscription": self = .subscription
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum SubscriptionGroups: Hashable, Codable, RawRepresentable {
                case app
                case referenceName
                case subscriptionGroupLocalizations
                case subscriptions
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .referenceName: return "referenceName"
                    case .subscriptionGroupLocalizations: return "subscriptionGroupLocalizations"
                    case .subscriptions: return "subscriptions"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "referenceName": self = .referenceName
                    case "subscriptionGroupLocalizations": self = .subscriptionGroupLocalizations
                    case "subscriptions": self = .subscriptions
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum SubscriptionIntroductoryOffers: Hashable, Codable, RawRepresentable {
                case duration
                case endDate
                case numberOfPeriods
                case offerMode
                case startDate
                case subscription
                case subscriptionPricePoint
                case territory
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .duration: return "duration"
                    case .endDate: return "endDate"
                    case .numberOfPeriods: return "numberOfPeriods"
                    case .offerMode: return "offerMode"
                    case .startDate: return "startDate"
                    case .subscription: return "subscription"
                    case .subscriptionPricePoint: return "subscriptionPricePoint"
                    case .territory: return "territory"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "duration": self = .duration
                    case "endDate": self = .endDate
                    case "numberOfPeriods": self = .numberOfPeriods
                    case "offerMode": self = .offerMode
                    case "startDate": self = .startDate
                    case "subscription": self = .subscription
                    case "subscriptionPricePoint": self = .subscriptionPricePoint
                    case "territory": self = .territory
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum SubscriptionLocalizations: Hashable, Codable, RawRepresentable {
                case description
                case locale
                case name
                case state
                case subscription
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .description: return "description"
                    case .locale: return "locale"
                    case .name: return "name"
                    case .state: return "state"
                    case .subscription: return "subscription"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "description": self = .description
                    case "locale": self = .locale
                    case "name": self = .name
                    case "state": self = .state
                    case "subscription": self = .subscription
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum SubscriptionOfferCodes: Hashable, Codable, RawRepresentable {
                case active
                case customCodes
                case customerEligibilities
                case duration
                case name
                case numberOfPeriods
                case offerEligibility
                case offerMode
                case oneTimeUseCodes
                case prices
                case subscription
                case totalNumberOfCodes
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .active: return "active"
                    case .customCodes: return "customCodes"
                    case .customerEligibilities: return "customerEligibilities"
                    case .duration: return "duration"
                    case .name: return "name"
                    case .numberOfPeriods: return "numberOfPeriods"
                    case .offerEligibility: return "offerEligibility"
                    case .offerMode: return "offerMode"
                    case .oneTimeUseCodes: return "oneTimeUseCodes"
                    case .prices: return "prices"
                    case .subscription: return "subscription"
                    case .totalNumberOfCodes: return "totalNumberOfCodes"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "active": self = .active
                    case "customCodes": self = .customCodes
                    case "customerEligibilities": self = .customerEligibilities
                    case "duration": self = .duration
                    case "name": self = .name
                    case "numberOfPeriods": self = .numberOfPeriods
                    case "offerEligibility": self = .offerEligibility
                    case "offerMode": self = .offerMode
                    case "oneTimeUseCodes": self = .oneTimeUseCodes
                    case "prices": self = .prices
                    case "subscription": self = .subscription
                    case "totalNumberOfCodes": self = .totalNumberOfCodes
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum SubscriptionPrices: Hashable, Codable, RawRepresentable {
                case preserveCurrentPrice
                case preserved
                case startDate
                case subscription
                case subscriptionPricePoint
                case territory
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .preserveCurrentPrice: return "preserveCurrentPrice"
                    case .preserved: return "preserved"
                    case .startDate: return "startDate"
                    case .subscription: return "subscription"
                    case .subscriptionPricePoint: return "subscriptionPricePoint"
                    case .territory: return "territory"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "preserveCurrentPrice": self = .preserveCurrentPrice
                    case "preserved": self = .preserved
                    case "startDate": self = .startDate
                    case "subscription": self = .subscription
                    case "subscriptionPricePoint": self = .subscriptionPricePoint
                    case "territory": self = .territory
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum SubscriptionPromotionalOffers: Hashable, Codable, RawRepresentable {
                case duration
                case name
                case numberOfPeriods
                case offerCode
                case offerMode
                case prices
                case subscription
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .duration: return "duration"
                    case .name: return "name"
                    case .numberOfPeriods: return "numberOfPeriods"
                    case .offerCode: return "offerCode"
                    case .offerMode: return "offerMode"
                    case .prices: return "prices"
                    case .subscription: return "subscription"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "duration": self = .duration
                    case "name": self = .name
                    case "numberOfPeriods": self = .numberOfPeriods
                    case "offerCode": self = .offerCode
                    case "offerMode": self = .offerMode
                    case "prices": self = .prices
                    case "subscription": self = .subscription
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Subscriptions: Hashable, Codable, RawRepresentable {
                case appStoreReviewScreenshot
                case availableInAllTerritories
                case familySharable
                case group
                case groupLevel
                case introductoryOffers
                case name
                case offerCodes
                case pricePoints
                case prices
                case productId
                case promotedPurchase
                case promotionalOffers
                case reviewNote
                case state
                case subscriptionAvailability
                case subscriptionLocalizations
                case subscriptionPeriod
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appStoreReviewScreenshot: return "appStoreReviewScreenshot"
                    case .availableInAllTerritories: return "availableInAllTerritories"
                    case .familySharable: return "familySharable"
                    case .group: return "group"
                    case .groupLevel: return "groupLevel"
                    case .introductoryOffers: return "introductoryOffers"
                    case .name: return "name"
                    case .offerCodes: return "offerCodes"
                    case .pricePoints: return "pricePoints"
                    case .prices: return "prices"
                    case .productId: return "productId"
                    case .promotedPurchase: return "promotedPurchase"
                    case .promotionalOffers: return "promotionalOffers"
                    case .reviewNote: return "reviewNote"
                    case .state: return "state"
                    case .subscriptionAvailability: return "subscriptionAvailability"
                    case .subscriptionLocalizations: return "subscriptionLocalizations"
                    case .subscriptionPeriod: return "subscriptionPeriod"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "appStoreReviewScreenshot": self = .appStoreReviewScreenshot
                    case "availableInAllTerritories": self = .availableInAllTerritories
                    case "familySharable": self = .familySharable
                    case "group": self = .group
                    case "groupLevel": self = .groupLevel
                    case "introductoryOffers": self = .introductoryOffers
                    case "name": self = .name
                    case "offerCodes": self = .offerCodes
                    case "pricePoints": self = .pricePoints
                    case "prices": self = .prices
                    case "productId": self = .productId
                    case "promotedPurchase": self = .promotedPurchase
                    case "promotionalOffers": self = .promotionalOffers
                    case "reviewNote": self = .reviewNote
                    case "state": self = .state
                    case "subscriptionAvailability": self = .subscriptionAvailability
                    case "subscriptionLocalizations": self = .subscriptionLocalizations
                    case "subscriptionPeriod": self = .subscriptionPeriod
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type promotedPurchases
                public static var promotedPurchases: Relation<[PromotedPurchases]?> {
                    .init(key: "fields[promotedPurchases]")
                }

                /// the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
                public static var subscriptionAppStoreReviewScreenshots: Relation<[SubscriptionAppStoreReviewScreenshots]?> {
                    .init(key: "fields[subscriptionAppStoreReviewScreenshots]")
                }

                /// the fields to include for returned resources of type subscriptionAvailabilities
                public static var subscriptionAvailabilities: Relation<[SubscriptionAvailabilities]?> {
                    .init(key: "fields[subscriptionAvailabilities]")
                }

                /// the fields to include for returned resources of type subscriptionGroups
                public static var subscriptionGroups: Relation<[SubscriptionGroups]?> {
                    .init(key: "fields[subscriptionGroups]")
                }

                /// the fields to include for returned resources of type subscriptionIntroductoryOffers
                public static var subscriptionIntroductoryOffers: Relation<[SubscriptionIntroductoryOffers]?> {
                    .init(key: "fields[subscriptionIntroductoryOffers]")
                }

                /// the fields to include for returned resources of type subscriptionLocalizations
                public static var subscriptionLocalizations: Relation<[SubscriptionLocalizations]?> {
                    .init(key: "fields[subscriptionLocalizations]")
                }

                /// the fields to include for returned resources of type subscriptionOfferCodes
                public static var subscriptionOfferCodes: Relation<[SubscriptionOfferCodes]?> {
                    .init(key: "fields[subscriptionOfferCodes]")
                }

                /// the fields to include for returned resources of type subscriptionPrices
                public static var subscriptionPrices: Relation<[SubscriptionPrices]?> {
                    .init(key: "fields[subscriptionPrices]")
                }

                /// the fields to include for returned resources of type subscriptionPromotionalOffers
                public static var subscriptionPromotionalOffers: Relation<[SubscriptionPromotionalOffers]?> {
                    .init(key: "fields[subscriptionPromotionalOffers]")
                }

                /// the fields to include for returned resources of type subscriptions
                public static var subscriptions: Relation<[Subscriptions]?> {
                    .init(key: "fields[subscriptions]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum State: Hashable, Codable, RawRepresentable {
                case approved
                case developerActionNeeded
                case developerRemovedFromSale
                case inReview
                case missingMetadata
                case pendingBinaryApproval
                case readyToSubmit
                case rejected
                case removedFromSale
                case waitingForReview
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .approved: return "APPROVED"
                    case .developerActionNeeded: return "DEVELOPER_ACTION_NEEDED"
                    case .developerRemovedFromSale: return "DEVELOPER_REMOVED_FROM_SALE"
                    case .inReview: return "IN_REVIEW"
                    case .missingMetadata: return "MISSING_METADATA"
                    case .pendingBinaryApproval: return "PENDING_BINARY_APPROVAL"
                    case .readyToSubmit: return "READY_TO_SUBMIT"
                    case .rejected: return "REJECTED"
                    case .removedFromSale: return "REMOVED_FROM_SALE"
                    case .waitingForReview: return "WAITING_FOR_REVIEW"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "APPROVED": self = .approved
                    case "DEVELOPER_ACTION_NEEDED": self = .developerActionNeeded
                    case "DEVELOPER_REMOVED_FROM_SALE": self = .developerRemovedFromSale
                    case "IN_REVIEW": self = .inReview
                    case "MISSING_METADATA": self = .missingMetadata
                    case "PENDING_BINARY_APPROVAL": self = .pendingBinaryApproval
                    case "READY_TO_SUBMIT": self = .readyToSubmit
                    case "REJECTED": self = .rejected
                    case "REMOVED_FROM_SALE": self = .removedFromSale
                    case "WAITING_FOR_REVIEW": self = .waitingForReview
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// filter by attribute 'name'
                public static var name: Relation<[String]?> {
                    .init(key: "filter[name]")
                }

                /// filter by attribute 'productId'
                public static var productId: Relation<[String]?> {
                    .init(key: "filter[productId]")
                }

                /// filter by attribute 'state'
                public static var state: Relation<[State]?> {
                    .init(key: "filter[state]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case appStoreReviewScreenshot
            case group
            case introductoryOffers
            case offerCodes
            case prices
            case promotedPurchase
            case promotionalOffers
            case subscriptionAvailability
            case subscriptionLocalizations
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .appStoreReviewScreenshot: return "appStoreReviewScreenshot"
                case .group: return "group"
                case .introductoryOffers: return "introductoryOffers"
                case .offerCodes: return "offerCodes"
                case .prices: return "prices"
                case .promotedPurchase: return "promotedPurchase"
                case .promotionalOffers: return "promotionalOffers"
                case .subscriptionAvailability: return "subscriptionAvailability"
                case .subscriptionLocalizations: return "subscriptionLocalizations"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "appStoreReviewScreenshot": self = .appStoreReviewScreenshot
                case "group": self = .group
                case "introductoryOffers": self = .introductoryOffers
                case "offerCodes": self = .offerCodes
                case "prices": self = .prices
                case "promotedPurchase": self = .promotedPurchase
                case "promotionalOffers": self = .promotionalOffers
                case "subscriptionAvailability": self = .subscriptionAvailability
                case "subscriptionLocalizations": self = .subscriptionLocalizations
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related introductoryOffers returned (when they are included)
                public static var introductoryOffers: Relation<Int?> {
                    .init(key: "limit[introductoryOffers]")
                }

                /// maximum number of related offerCodes returned (when they are included)
                public static var offerCodes: Relation<Int?> {
                    .init(key: "limit[offerCodes]")
                }

                /// maximum number of related prices returned (when they are included)
                public static var prices: Relation<Int?> {
                    .init(key: "limit[prices]")
                }

                /// maximum number of related promotionalOffers returned (when they are included)
                public static var promotionalOffers: Relation<Int?> {
                    .init(key: "limit[promotionalOffers]")
                }

                /// maximum number of related subscriptionLocalizations returned (when they are included)
                public static var subscriptionLocalizations: Relation<Int?> {
                    .init(key: "limit[subscriptionLocalizations]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Sort: Hashable, Codable, RawRepresentable {
            case name
            case nameDesc
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .name: return "name"
                case .nameDesc: return "-name"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "name": self = .name
                case "-name": self = .nameDesc
                default: self = .unknown(rawValue)
                }
            }
        }
    }
}

// swiftlint:enable all
