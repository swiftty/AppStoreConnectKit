// autogenerated

// swiftlint:disable all
import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension V1.Profiles {
    public struct GET: Endpoint {
        public typealias Response = ProfilesResponse

        public var path: String {
            "/v1/profiles"
        }

        public var parameters: Parameters = Parameters()

        public init() {

        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[bundleIds]",
                             value: parameters.fields[.bundleIds]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[certificates]",
                             value: parameters.fields[.certificates]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[devices]",
                             value: parameters.fields[.devices]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[profiles]",
                             value: parameters.fields[.profiles]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[id]",
                             value: parameters.filter[.id]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[name]",
                             value: parameters.filter[.name]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[profileState]",
                             value: parameters.filter[.profileState]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[profileType]",
                             value: parameters.filter[.profileType]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[certificates]",
                             value: parameters.limit[.certificates].map { "\($0)" }),
                URLQueryItem(name: "limit[devices]",
                             value: parameters.limit[.devices].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" }),
                URLQueryItem(name: "sort",
                             value: parameters.sort?.map { "\($0)" }.joined(separator: ","))
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of Profiles as `ProfilesResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(ProfilesResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.Profiles.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        /// comma-separated list of sort expressions; resources will be sorted as specified
        public var sort: [Sort]?

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum BundleIds: Hashable, Codable, RawRepresentable {
                case app
                case bundleIdCapabilities
                case identifier
                case name
                case platform
                case profiles
                case seedId
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .bundleIdCapabilities: return "bundleIdCapabilities"
                    case .identifier: return "identifier"
                    case .name: return "name"
                    case .platform: return "platform"
                    case .profiles: return "profiles"
                    case .seedId: return "seedId"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "bundleIdCapabilities": self = .bundleIdCapabilities
                    case "identifier": self = .identifier
                    case "name": self = .name
                    case "platform": self = .platform
                    case "profiles": self = .profiles
                    case "seedId": self = .seedId
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Certificates: Hashable, Codable, RawRepresentable {
                case certificateContent
                case certificateType
                case csrContent
                case displayName
                case expirationDate
                case name
                case platform
                case serialNumber
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .certificateContent: return "certificateContent"
                    case .certificateType: return "certificateType"
                    case .csrContent: return "csrContent"
                    case .displayName: return "displayName"
                    case .expirationDate: return "expirationDate"
                    case .name: return "name"
                    case .platform: return "platform"
                    case .serialNumber: return "serialNumber"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "certificateContent": self = .certificateContent
                    case "certificateType": self = .certificateType
                    case "csrContent": self = .csrContent
                    case "displayName": self = .displayName
                    case "expirationDate": self = .expirationDate
                    case "name": self = .name
                    case "platform": self = .platform
                    case "serialNumber": self = .serialNumber
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Devices: Hashable, Codable, RawRepresentable {
                case addedDate
                case deviceClass
                case model
                case name
                case platform
                case status
                case udid
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .addedDate: return "addedDate"
                    case .deviceClass: return "deviceClass"
                    case .model: return "model"
                    case .name: return "name"
                    case .platform: return "platform"
                    case .status: return "status"
                    case .udid: return "udid"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "addedDate": self = .addedDate
                    case "deviceClass": self = .deviceClass
                    case "model": self = .model
                    case "name": self = .name
                    case "platform": self = .platform
                    case "status": self = .status
                    case "udid": self = .udid
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Profiles: Hashable, Codable, RawRepresentable {
                case bundleId
                case certificates
                case createdDate
                case devices
                case expirationDate
                case name
                case platform
                case profileContent
                case profileState
                case profileType
                case uuid
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .bundleId: return "bundleId"
                    case .certificates: return "certificates"
                    case .createdDate: return "createdDate"
                    case .devices: return "devices"
                    case .expirationDate: return "expirationDate"
                    case .name: return "name"
                    case .platform: return "platform"
                    case .profileContent: return "profileContent"
                    case .profileState: return "profileState"
                    case .profileType: return "profileType"
                    case .uuid: return "uuid"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "bundleId": self = .bundleId
                    case "certificates": self = .certificates
                    case "createdDate": self = .createdDate
                    case "devices": self = .devices
                    case "expirationDate": self = .expirationDate
                    case "name": self = .name
                    case "platform": self = .platform
                    case "profileContent": self = .profileContent
                    case "profileState": self = .profileState
                    case "profileType": self = .profileType
                    case "uuid": self = .uuid
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type bundleIds
                public static var bundleIds: Relation<[BundleIds]?> {
                    .init(key: "fields[bundleIds]")
                }

                /// the fields to include for returned resources of type certificates
                public static var certificates: Relation<[Certificates]?> {
                    .init(key: "fields[certificates]")
                }

                /// the fields to include for returned resources of type devices
                public static var devices: Relation<[Devices]?> {
                    .init(key: "fields[devices]")
                }

                /// the fields to include for returned resources of type profiles
                public static var profiles: Relation<[Profiles]?> {
                    .init(key: "fields[profiles]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum ProfileState: Hashable, Codable, RawRepresentable {
                case active
                case invalid
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .active: return "ACTIVE"
                    case .invalid: return "INVALID"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "ACTIVE": self = .active
                    case "INVALID": self = .invalid
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum ProfileType: Hashable, Codable, RawRepresentable {
                case iOSAppAdhoc
                case iOSAppDevelopment
                case iOSAppInhouse
                case iOSAppStore
                case macAppDevelopment
                case macAppDirect
                case macAppStore
                case macCatalystAppDevelopment
                case macCatalystAppDirect
                case macCatalystAppStore
                case tvOSAppAdhoc
                case tvOSAppDevelopment
                case tvOSAppInhouse
                case tvOSAppStore
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .iOSAppAdhoc: return "IOS_APP_ADHOC"
                    case .iOSAppDevelopment: return "IOS_APP_DEVELOPMENT"
                    case .iOSAppInhouse: return "IOS_APP_INHOUSE"
                    case .iOSAppStore: return "IOS_APP_STORE"
                    case .macAppDevelopment: return "MAC_APP_DEVELOPMENT"
                    case .macAppDirect: return "MAC_APP_DIRECT"
                    case .macAppStore: return "MAC_APP_STORE"
                    case .macCatalystAppDevelopment: return "MAC_CATALYST_APP_DEVELOPMENT"
                    case .macCatalystAppDirect: return "MAC_CATALYST_APP_DIRECT"
                    case .macCatalystAppStore: return "MAC_CATALYST_APP_STORE"
                    case .tvOSAppAdhoc: return "TVOS_APP_ADHOC"
                    case .tvOSAppDevelopment: return "TVOS_APP_DEVELOPMENT"
                    case .tvOSAppInhouse: return "TVOS_APP_INHOUSE"
                    case .tvOSAppStore: return "TVOS_APP_STORE"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "IOS_APP_ADHOC": self = .iOSAppAdhoc
                    case "IOS_APP_DEVELOPMENT": self = .iOSAppDevelopment
                    case "IOS_APP_INHOUSE": self = .iOSAppInhouse
                    case "IOS_APP_STORE": self = .iOSAppStore
                    case "MAC_APP_DEVELOPMENT": self = .macAppDevelopment
                    case "MAC_APP_DIRECT": self = .macAppDirect
                    case "MAC_APP_STORE": self = .macAppStore
                    case "MAC_CATALYST_APP_DEVELOPMENT": self = .macCatalystAppDevelopment
                    case "MAC_CATALYST_APP_DIRECT": self = .macCatalystAppDirect
                    case "MAC_CATALYST_APP_STORE": self = .macCatalystAppStore
                    case "TVOS_APP_ADHOC": self = .tvOSAppAdhoc
                    case "TVOS_APP_DEVELOPMENT": self = .tvOSAppDevelopment
                    case "TVOS_APP_INHOUSE": self = .tvOSAppInhouse
                    case "TVOS_APP_STORE": self = .tvOSAppStore
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// filter by id(s)
                public static var id: Relation<[String]?> {
                    .init(key: "filter[id]")
                }

                /// filter by attribute 'name'
                public static var name: Relation<[String]?> {
                    .init(key: "filter[name]")
                }

                /// filter by attribute 'profileState'
                public static var profileState: Relation<[ProfileState]?> {
                    .init(key: "filter[profileState]")
                }

                /// filter by attribute 'profileType'
                public static var profileType: Relation<[ProfileType]?> {
                    .init(key: "filter[profileType]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case bundleId
            case certificates
            case devices
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .bundleId: return "bundleId"
                case .certificates: return "certificates"
                case .devices: return "devices"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "bundleId": self = .bundleId
                case "certificates": self = .certificates
                case "devices": self = .devices
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related certificates returned (when they are included)
                public static var certificates: Relation<Int?> {
                    .init(key: "limit[certificates]")
                }

                /// maximum number of related devices returned (when they are included)
                public static var devices: Relation<Int?> {
                    .init(key: "limit[devices]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Sort: Hashable, Codable, RawRepresentable {
            case id
            case idDesc
            case name
            case nameDesc
            case profileState
            case profileStateDesc
            case profileType
            case profileTypeDesc
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .id: return "id"
                case .idDesc: return "-id"
                case .name: return "name"
                case .nameDesc: return "-name"
                case .profileState: return "profileState"
                case .profileStateDesc: return "-profileState"
                case .profileType: return "profileType"
                case .profileTypeDesc: return "-profileType"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "id": self = .id
                case "-id": self = .idDesc
                case "name": self = .name
                case "-name": self = .nameDesc
                case "profileState": self = .profileState
                case "-profileState": self = .profileStateDesc
                case "profileType": self = .profileType
                case "-profileType": self = .profileTypeDesc
                default: self = .unknown(rawValue)
                }
            }
        }
    }
}

// swiftlint:enable all
