// autogenerated

// swiftlint:disable all
import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension V1.Apps.ById.AppStoreVersions {
    public struct GET: Endpoint {
        public typealias Response = AppStoreVersionsResponse

        public var path: String {
            "/v1/apps/\(id)/appStoreVersions"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[appStoreVersionExperiments]",
                             value: parameters.fields[.appStoreVersionExperiments]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersionLocalizations]",
                             value: parameters.fields[.appStoreVersionLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersions]",
                             value: parameters.fields[.appStoreVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[appStoreState]",
                             value: parameters.filter[.appStoreState]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[id]",
                             value: parameters.filter[.id]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[platform]",
                             value: parameters.filter[.platform]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[versionString]",
                             value: parameters.filter[.versionString]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[appStoreVersionExperiments]",
                             value: parameters.limit[.appStoreVersionExperiments].map { "\($0)" }),
                URLQueryItem(name: "limit[appStoreVersionLocalizations]",
                             value: parameters.limit[.appStoreVersionLocalizations].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" })
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of related resources as `AppStoreVersionsResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(AppStoreVersionsResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.Apps.ById.AppStoreVersions.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppStoreVersionExperiments: Hashable, Codable, RawRepresentable {
                case appStoreVersion
                case appStoreVersionExperimentTreatments
                case endDate
                case name
                case reviewRequired
                case startDate
                case started
                case state
                case trafficProportion
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appStoreVersion: return "appStoreVersion"
                    case .appStoreVersionExperimentTreatments: return "appStoreVersionExperimentTreatments"
                    case .endDate: return "endDate"
                    case .name: return "name"
                    case .reviewRequired: return "reviewRequired"
                    case .startDate: return "startDate"
                    case .started: return "started"
                    case .state: return "state"
                    case .trafficProportion: return "trafficProportion"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "appStoreVersion": self = .appStoreVersion
                    case "appStoreVersionExperimentTreatments": self = .appStoreVersionExperimentTreatments
                    case "endDate": self = .endDate
                    case "name": self = .name
                    case "reviewRequired": self = .reviewRequired
                    case "startDate": self = .startDate
                    case "started": self = .started
                    case "state": self = .state
                    case "trafficProportion": self = .trafficProportion
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppStoreVersionLocalizations: Hashable, Codable, RawRepresentable {
                case appPreviewSets
                case appScreenshotSets
                case appStoreVersion
                case description
                case keywords
                case locale
                case marketingUrl
                case promotionalText
                case supportUrl
                case whatsNew
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appPreviewSets: return "appPreviewSets"
                    case .appScreenshotSets: return "appScreenshotSets"
                    case .appStoreVersion: return "appStoreVersion"
                    case .description: return "description"
                    case .keywords: return "keywords"
                    case .locale: return "locale"
                    case .marketingUrl: return "marketingUrl"
                    case .promotionalText: return "promotionalText"
                    case .supportUrl: return "supportUrl"
                    case .whatsNew: return "whatsNew"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "appPreviewSets": self = .appPreviewSets
                    case "appScreenshotSets": self = .appScreenshotSets
                    case "appStoreVersion": self = .appStoreVersion
                    case "description": self = .description
                    case "keywords": self = .keywords
                    case "locale": self = .locale
                    case "marketingUrl": self = .marketingUrl
                    case "promotionalText": self = .promotionalText
                    case "supportUrl": self = .supportUrl
                    case "whatsNew": self = .whatsNew
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppStoreVersions: Hashable, Codable, RawRepresentable {
                case ageRatingDeclaration
                case app
                case appClipDefaultExperience
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionExperiments
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .ageRatingDeclaration: return "ageRatingDeclaration"
                    case .app: return "app"
                    case .appClipDefaultExperience: return "appClipDefaultExperience"
                    case .appStoreReviewDetail: return "appStoreReviewDetail"
                    case .appStoreState: return "appStoreState"
                    case .appStoreVersionExperiments: return "appStoreVersionExperiments"
                    case .appStoreVersionLocalizations: return "appStoreVersionLocalizations"
                    case .appStoreVersionPhasedRelease: return "appStoreVersionPhasedRelease"
                    case .appStoreVersionSubmission: return "appStoreVersionSubmission"
                    case .build: return "build"
                    case .copyright: return "copyright"
                    case .createdDate: return "createdDate"
                    case .downloadable: return "downloadable"
                    case .earliestReleaseDate: return "earliestReleaseDate"
                    case .idfaDeclaration: return "idfaDeclaration"
                    case .platform: return "platform"
                    case .releaseType: return "releaseType"
                    case .routingAppCoverage: return "routingAppCoverage"
                    case .usesIdfa: return "usesIdfa"
                    case .versionString: return "versionString"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "ageRatingDeclaration": self = .ageRatingDeclaration
                    case "app": self = .app
                    case "appClipDefaultExperience": self = .appClipDefaultExperience
                    case "appStoreReviewDetail": self = .appStoreReviewDetail
                    case "appStoreState": self = .appStoreState
                    case "appStoreVersionExperiments": self = .appStoreVersionExperiments
                    case "appStoreVersionLocalizations": self = .appStoreVersionLocalizations
                    case "appStoreVersionPhasedRelease": self = .appStoreVersionPhasedRelease
                    case "appStoreVersionSubmission": self = .appStoreVersionSubmission
                    case "build": self = .build
                    case "copyright": self = .copyright
                    case "createdDate": self = .createdDate
                    case "downloadable": self = .downloadable
                    case "earliestReleaseDate": self = .earliestReleaseDate
                    case "idfaDeclaration": self = .idfaDeclaration
                    case "platform": self = .platform
                    case "releaseType": self = .releaseType
                    case "routingAppCoverage": self = .routingAppCoverage
                    case "usesIdfa": self = .usesIdfa
                    case "versionString": self = .versionString
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type appStoreVersionExperiments
                public static var appStoreVersionExperiments: Relation<[AppStoreVersionExperiments]?> {
                    .init(key: "fields[appStoreVersionExperiments]")
                }

                /// the fields to include for returned resources of type appStoreVersionLocalizations
                public static var appStoreVersionLocalizations: Relation<[AppStoreVersionLocalizations]?> {
                    .init(key: "fields[appStoreVersionLocalizations]")
                }

                /// the fields to include for returned resources of type appStoreVersions
                public static var appStoreVersions: Relation<[AppStoreVersions]?> {
                    .init(key: "fields[appStoreVersions]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppStoreState: Hashable, Codable, RawRepresentable {
                case accepted
                case developerRejected
                case developerRemovedFromSale
                case inReview
                case invalidBinary
                case metadataRejected
                case pendingAppleRelease
                case pendingContract
                case pendingDeveloperRelease
                case preorderReadyForSale
                case prepareForSubmission
                case processingForAppStore
                case readyForReview
                case readyForSale
                case rejected
                case removedFromSale
                case replacedWithNewVersion
                case waitingForExportCompliance
                case waitingForReview
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .accepted: return "ACCEPTED"
                    case .developerRejected: return "DEVELOPER_REJECTED"
                    case .developerRemovedFromSale: return "DEVELOPER_REMOVED_FROM_SALE"
                    case .inReview: return "IN_REVIEW"
                    case .invalidBinary: return "INVALID_BINARY"
                    case .metadataRejected: return "METADATA_REJECTED"
                    case .pendingAppleRelease: return "PENDING_APPLE_RELEASE"
                    case .pendingContract: return "PENDING_CONTRACT"
                    case .pendingDeveloperRelease: return "PENDING_DEVELOPER_RELEASE"
                    case .preorderReadyForSale: return "PREORDER_READY_FOR_SALE"
                    case .prepareForSubmission: return "PREPARE_FOR_SUBMISSION"
                    case .processingForAppStore: return "PROCESSING_FOR_APP_STORE"
                    case .readyForReview: return "READY_FOR_REVIEW"
                    case .readyForSale: return "READY_FOR_SALE"
                    case .rejected: return "REJECTED"
                    case .removedFromSale: return "REMOVED_FROM_SALE"
                    case .replacedWithNewVersion: return "REPLACED_WITH_NEW_VERSION"
                    case .waitingForExportCompliance: return "WAITING_FOR_EXPORT_COMPLIANCE"
                    case .waitingForReview: return "WAITING_FOR_REVIEW"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "ACCEPTED": self = .accepted
                    case "DEVELOPER_REJECTED": self = .developerRejected
                    case "DEVELOPER_REMOVED_FROM_SALE": self = .developerRemovedFromSale
                    case "IN_REVIEW": self = .inReview
                    case "INVALID_BINARY": self = .invalidBinary
                    case "METADATA_REJECTED": self = .metadataRejected
                    case "PENDING_APPLE_RELEASE": self = .pendingAppleRelease
                    case "PENDING_CONTRACT": self = .pendingContract
                    case "PENDING_DEVELOPER_RELEASE": self = .pendingDeveloperRelease
                    case "PREORDER_READY_FOR_SALE": self = .preorderReadyForSale
                    case "PREPARE_FOR_SUBMISSION": self = .prepareForSubmission
                    case "PROCESSING_FOR_APP_STORE": self = .processingForAppStore
                    case "READY_FOR_REVIEW": self = .readyForReview
                    case "READY_FOR_SALE": self = .readyForSale
                    case "REJECTED": self = .rejected
                    case "REMOVED_FROM_SALE": self = .removedFromSale
                    case "REPLACED_WITH_NEW_VERSION": self = .replacedWithNewVersion
                    case "WAITING_FOR_EXPORT_COMPLIANCE": self = .waitingForExportCompliance
                    case "WAITING_FOR_REVIEW": self = .waitingForReview
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Platform: Hashable, Codable, RawRepresentable {
                case iOS
                case macOS
                case tvOS
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .iOS: return "IOS"
                    case .macOS: return "MAC_OS"
                    case .tvOS: return "TV_OS"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "IOS": self = .iOS
                    case "MAC_OS": self = .macOS
                    case "TV_OS": self = .tvOS
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// filter by attribute 'appStoreState'
                public static var appStoreState: Relation<[AppStoreState]?> {
                    .init(key: "filter[appStoreState]")
                }

                /// filter by id(s)
                public static var id: Relation<[String]?> {
                    .init(key: "filter[id]")
                }

                /// filter by attribute 'platform'
                public static var platform: Relation<[Platform]?> {
                    .init(key: "filter[platform]")
                }

                /// filter by attribute 'versionString'
                public static var versionString: Relation<[String]?> {
                    .init(key: "filter[versionString]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case appStoreVersionExperiments
            case appStoreVersionLocalizations
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .appStoreVersionExperiments: return "appStoreVersionExperiments"
                case .appStoreVersionLocalizations: return "appStoreVersionLocalizations"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "appStoreVersionExperiments": self = .appStoreVersionExperiments
                case "appStoreVersionLocalizations": self = .appStoreVersionLocalizations
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related appStoreVersionExperiments returned (when they are included)
                public static var appStoreVersionExperiments: Relation<Int?> {
                    .init(key: "limit[appStoreVersionExperiments]")
                }

                /// maximum number of related appStoreVersionLocalizations returned (when they are included)
                public static var appStoreVersionLocalizations: Relation<Int?> {
                    .init(key: "limit[appStoreVersionLocalizations]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }
    }
}

// swiftlint:enable all
