// autogenerated

// swiftlint:disable all
import Foundation

extension V1.Apps.ById.AppInfos {
    public struct GET: Endpoint {
        public typealias Response = AppInfosResponse

        public var path: String {
            "/v1/apps/\(id)/appInfos"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[appInfoLocalizations]",
                             value: parameters.fields[.appInfoLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appInfos]",
                             value: parameters.fields[.appInfos]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[appInfoLocalizations]",
                             value: parameters.limit[.appInfoLocalizations].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" })
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of related resources as `AppInfosResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(AppInfosResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.Apps.ById.AppInfos.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppInfoLocalizations: Hashable, Codable, RawRepresentable {
                case appInfo
                case locale
                case name
                case privacyChoicesUrl
                case privacyPolicyText
                case privacyPolicyUrl
                case subtitle
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appInfo: return "appInfo"
                    case .locale: return "locale"
                    case .name: return "name"
                    case .privacyChoicesUrl: return "privacyChoicesUrl"
                    case .privacyPolicyText: return "privacyPolicyText"
                    case .privacyPolicyUrl: return "privacyPolicyUrl"
                    case .subtitle: return "subtitle"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "appInfo": self = .appInfo
                    case "locale": self = .locale
                    case "name": self = .name
                    case "privacyChoicesUrl": self = .privacyChoicesUrl
                    case "privacyPolicyText": self = .privacyPolicyText
                    case "privacyPolicyUrl": self = .privacyPolicyUrl
                    case "subtitle": self = .subtitle
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppInfos: Hashable, Codable, RawRepresentable {
                case ageRatingDeclaration
                case app
                case appInfoLocalizations
                case appStoreAgeRating
                case appStoreState
                case brazilAgeRating
                case kidsAgeBand
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .ageRatingDeclaration: return "ageRatingDeclaration"
                    case .app: return "app"
                    case .appInfoLocalizations: return "appInfoLocalizations"
                    case .appStoreAgeRating: return "appStoreAgeRating"
                    case .appStoreState: return "appStoreState"
                    case .brazilAgeRating: return "brazilAgeRating"
                    case .kidsAgeBand: return "kidsAgeBand"
                    case .primaryCategory: return "primaryCategory"
                    case .primarySubcategoryOne: return "primarySubcategoryOne"
                    case .primarySubcategoryTwo: return "primarySubcategoryTwo"
                    case .secondaryCategory: return "secondaryCategory"
                    case .secondarySubcategoryOne: return "secondarySubcategoryOne"
                    case .secondarySubcategoryTwo: return "secondarySubcategoryTwo"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "ageRatingDeclaration": self = .ageRatingDeclaration
                    case "app": self = .app
                    case "appInfoLocalizations": self = .appInfoLocalizations
                    case "appStoreAgeRating": self = .appStoreAgeRating
                    case "appStoreState": self = .appStoreState
                    case "brazilAgeRating": self = .brazilAgeRating
                    case "kidsAgeBand": self = .kidsAgeBand
                    case "primaryCategory": self = .primaryCategory
                    case "primarySubcategoryOne": self = .primarySubcategoryOne
                    case "primarySubcategoryTwo": self = .primarySubcategoryTwo
                    case "secondaryCategory": self = .secondaryCategory
                    case "secondarySubcategoryOne": self = .secondarySubcategoryOne
                    case "secondarySubcategoryTwo": self = .secondarySubcategoryTwo
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type appInfoLocalizations
                public static var appInfoLocalizations: Relation<[AppInfoLocalizations]?> {
                    .init(key: "fields[appInfoLocalizations]")
                }

                /// the fields to include for returned resources of type appInfos
                public static var appInfos: Relation<[AppInfos]?> {
                    .init(key: "fields[appInfos]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case appInfoLocalizations
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .appInfoLocalizations: return "appInfoLocalizations"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "appInfoLocalizations": self = .appInfoLocalizations
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related appInfoLocalizations returned (when they are included)
                public static var appInfoLocalizations: Relation<Int?> {
                    .init(key: "limit[appInfoLocalizations]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }
    }
}

// swiftlint:enable all
