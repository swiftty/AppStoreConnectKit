// autogenerated

// swiftlint:disable all
import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension V1.Apps.ById.InAppPurchasesV2 {
    public struct GET: Endpoint {
        public typealias Response = InAppPurchasesV2Response

        public var path: String {
            "/v1/apps/\(id)/inAppPurchasesV2"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[inAppPurchaseAppStoreReviewScreenshots]",
                             value: parameters.fields[.inAppPurchaseAppStoreReviewScreenshots]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[inAppPurchaseAvailabilities]",
                             value: parameters.fields[.inAppPurchaseAvailabilities]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[inAppPurchaseContents]",
                             value: parameters.fields[.inAppPurchaseContents]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[inAppPurchaseLocalizations]",
                             value: parameters.fields[.inAppPurchaseLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[inAppPurchasePriceSchedules]",
                             value: parameters.fields[.inAppPurchasePriceSchedules]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[inAppPurchases]",
                             value: parameters.fields[.inAppPurchases]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[promotedPurchases]",
                             value: parameters.fields[.promotedPurchases]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[inAppPurchaseType]",
                             value: parameters.filter[.inAppPurchaseType]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[name]",
                             value: parameters.filter[.name]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[productId]",
                             value: parameters.filter[.productId]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[state]",
                             value: parameters.filter[.state]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[inAppPurchaseLocalizations]",
                             value: parameters.limit[.inAppPurchaseLocalizations].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" }),
                URLQueryItem(name: "sort",
                             value: parameters.sort?.map { "\($0)" }.joined(separator: ","))
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of InAppPurchases as `InAppPurchasesV2Response`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(InAppPurchasesV2Response.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.Apps.ById.InAppPurchasesV2.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        /// comma-separated list of sort expressions; resources will be sorted as specified
        public var sort: [Sort]?

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum InAppPurchaseAppStoreReviewScreenshots: Hashable, Codable, RawRepresentable {
                case assetDeliveryState
                case assetToken
                case assetType
                case fileName
                case fileSize
                case imageAsset
                case inAppPurchaseV2
                case sourceFileChecksum
                case uploadOperations
                case uploaded
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .assetDeliveryState: return "assetDeliveryState"
                    case .assetToken: return "assetToken"
                    case .assetType: return "assetType"
                    case .fileName: return "fileName"
                    case .fileSize: return "fileSize"
                    case .imageAsset: return "imageAsset"
                    case .inAppPurchaseV2: return "inAppPurchaseV2"
                    case .sourceFileChecksum: return "sourceFileChecksum"
                    case .uploadOperations: return "uploadOperations"
                    case .uploaded: return "uploaded"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "assetDeliveryState": self = .assetDeliveryState
                    case "assetToken": self = .assetToken
                    case "assetType": self = .assetType
                    case "fileName": self = .fileName
                    case "fileSize": self = .fileSize
                    case "imageAsset": self = .imageAsset
                    case "inAppPurchaseV2": self = .inAppPurchaseV2
                    case "sourceFileChecksum": self = .sourceFileChecksum
                    case "uploadOperations": self = .uploadOperations
                    case "uploaded": self = .uploaded
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum InAppPurchaseAvailabilities: Hashable, Codable, RawRepresentable {
                case availableInNewTerritories
                case availableTerritories
                case inAppPurchase
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .availableInNewTerritories: return "availableInNewTerritories"
                    case .availableTerritories: return "availableTerritories"
                    case .inAppPurchase: return "inAppPurchase"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "availableInNewTerritories": self = .availableInNewTerritories
                    case "availableTerritories": self = .availableTerritories
                    case "inAppPurchase": self = .inAppPurchase
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum InAppPurchaseContents: Hashable, Codable, RawRepresentable {
                case fileName
                case fileSize
                case inAppPurchaseV2
                case lastModifiedDate
                case url
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .fileName: return "fileName"
                    case .fileSize: return "fileSize"
                    case .inAppPurchaseV2: return "inAppPurchaseV2"
                    case .lastModifiedDate: return "lastModifiedDate"
                    case .url: return "url"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "fileName": self = .fileName
                    case "fileSize": self = .fileSize
                    case "inAppPurchaseV2": self = .inAppPurchaseV2
                    case "lastModifiedDate": self = .lastModifiedDate
                    case "url": self = .url
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum InAppPurchaseLocalizations: Hashable, Codable, RawRepresentable {
                case description
                case inAppPurchaseV2
                case locale
                case name
                case state
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .description: return "description"
                    case .inAppPurchaseV2: return "inAppPurchaseV2"
                    case .locale: return "locale"
                    case .name: return "name"
                    case .state: return "state"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "description": self = .description
                    case "inAppPurchaseV2": self = .inAppPurchaseV2
                    case "locale": self = .locale
                    case "name": self = .name
                    case "state": self = .state
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum InAppPurchasePriceSchedules: Hashable, Codable, RawRepresentable {
                case automaticPrices
                case baseTerritory
                case inAppPurchase
                case manualPrices
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .automaticPrices: return "automaticPrices"
                    case .baseTerritory: return "baseTerritory"
                    case .inAppPurchase: return "inAppPurchase"
                    case .manualPrices: return "manualPrices"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "automaticPrices": self = .automaticPrices
                    case "baseTerritory": self = .baseTerritory
                    case "inAppPurchase": self = .inAppPurchase
                    case "manualPrices": self = .manualPrices
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum InAppPurchases: Hashable, Codable, RawRepresentable {
                case app
                case appStoreReviewScreenshot
                case availableInAllTerritories
                case content
                case contentHosting
                case familySharable
                case iapPriceSchedule
                case inAppPurchaseAvailability
                case inAppPurchaseLocalizations
                case inAppPurchaseType
                case name
                case productId
                case promotedPurchase
                case reviewNote
                case state
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .appStoreReviewScreenshot: return "appStoreReviewScreenshot"
                    case .availableInAllTerritories: return "availableInAllTerritories"
                    case .content: return "content"
                    case .contentHosting: return "contentHosting"
                    case .familySharable: return "familySharable"
                    case .iapPriceSchedule: return "iapPriceSchedule"
                    case .inAppPurchaseAvailability: return "inAppPurchaseAvailability"
                    case .inAppPurchaseLocalizations: return "inAppPurchaseLocalizations"
                    case .inAppPurchaseType: return "inAppPurchaseType"
                    case .name: return "name"
                    case .productId: return "productId"
                    case .promotedPurchase: return "promotedPurchase"
                    case .reviewNote: return "reviewNote"
                    case .state: return "state"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "appStoreReviewScreenshot": self = .appStoreReviewScreenshot
                    case "availableInAllTerritories": self = .availableInAllTerritories
                    case "content": self = .content
                    case "contentHosting": self = .contentHosting
                    case "familySharable": self = .familySharable
                    case "iapPriceSchedule": self = .iapPriceSchedule
                    case "inAppPurchaseAvailability": self = .inAppPurchaseAvailability
                    case "inAppPurchaseLocalizations": self = .inAppPurchaseLocalizations
                    case "inAppPurchaseType": self = .inAppPurchaseType
                    case "name": self = .name
                    case "productId": self = .productId
                    case "promotedPurchase": self = .promotedPurchase
                    case "reviewNote": self = .reviewNote
                    case "state": self = .state
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum PromotedPurchases: Hashable, Codable, RawRepresentable {
                case app
                case enabled
                case inAppPurchaseV2
                case promotionImages
                case state
                case subscription
                case visibleForAllUsers
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .enabled: return "enabled"
                    case .inAppPurchaseV2: return "inAppPurchaseV2"
                    case .promotionImages: return "promotionImages"
                    case .state: return "state"
                    case .subscription: return "subscription"
                    case .visibleForAllUsers: return "visibleForAllUsers"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "enabled": self = .enabled
                    case "inAppPurchaseV2": self = .inAppPurchaseV2
                    case "promotionImages": self = .promotionImages
                    case "state": self = .state
                    case "subscription": self = .subscription
                    case "visibleForAllUsers": self = .visibleForAllUsers
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
                public static var inAppPurchaseAppStoreReviewScreenshots: Relation<[InAppPurchaseAppStoreReviewScreenshots]?> {
                    .init(key: "fields[inAppPurchaseAppStoreReviewScreenshots]")
                }

                /// the fields to include for returned resources of type inAppPurchaseAvailabilities
                public static var inAppPurchaseAvailabilities: Relation<[InAppPurchaseAvailabilities]?> {
                    .init(key: "fields[inAppPurchaseAvailabilities]")
                }

                /// the fields to include for returned resources of type inAppPurchaseContents
                public static var inAppPurchaseContents: Relation<[InAppPurchaseContents]?> {
                    .init(key: "fields[inAppPurchaseContents]")
                }

                /// the fields to include for returned resources of type inAppPurchaseLocalizations
                public static var inAppPurchaseLocalizations: Relation<[InAppPurchaseLocalizations]?> {
                    .init(key: "fields[inAppPurchaseLocalizations]")
                }

                /// the fields to include for returned resources of type inAppPurchasePriceSchedules
                public static var inAppPurchasePriceSchedules: Relation<[InAppPurchasePriceSchedules]?> {
                    .init(key: "fields[inAppPurchasePriceSchedules]")
                }

                /// the fields to include for returned resources of type inAppPurchases
                public static var inAppPurchases: Relation<[InAppPurchases]?> {
                    .init(key: "fields[inAppPurchases]")
                }

                /// the fields to include for returned resources of type promotedPurchases
                public static var promotedPurchases: Relation<[PromotedPurchases]?> {
                    .init(key: "fields[promotedPurchases]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum InAppPurchaseType: Hashable, Codable, RawRepresentable {
                case consumable
                case nonConsumable
                case nonRenewingSubscription
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .consumable: return "CONSUMABLE"
                    case .nonConsumable: return "NON_CONSUMABLE"
                    case .nonRenewingSubscription: return "NON_RENEWING_SUBSCRIPTION"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "CONSUMABLE": self = .consumable
                    case "NON_CONSUMABLE": self = .nonConsumable
                    case "NON_RENEWING_SUBSCRIPTION": self = .nonRenewingSubscription
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum State: Hashable, Codable, RawRepresentable {
                case approved
                case developerActionNeeded
                case developerRemovedFromSale
                case inReview
                case missingMetadata
                case pendingBinaryApproval
                case processingContent
                case readyToSubmit
                case rejected
                case removedFromSale
                case waitingForReview
                case waitingForUpload
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .approved: return "APPROVED"
                    case .developerActionNeeded: return "DEVELOPER_ACTION_NEEDED"
                    case .developerRemovedFromSale: return "DEVELOPER_REMOVED_FROM_SALE"
                    case .inReview: return "IN_REVIEW"
                    case .missingMetadata: return "MISSING_METADATA"
                    case .pendingBinaryApproval: return "PENDING_BINARY_APPROVAL"
                    case .processingContent: return "PROCESSING_CONTENT"
                    case .readyToSubmit: return "READY_TO_SUBMIT"
                    case .rejected: return "REJECTED"
                    case .removedFromSale: return "REMOVED_FROM_SALE"
                    case .waitingForReview: return "WAITING_FOR_REVIEW"
                    case .waitingForUpload: return "WAITING_FOR_UPLOAD"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "APPROVED": self = .approved
                    case "DEVELOPER_ACTION_NEEDED": self = .developerActionNeeded
                    case "DEVELOPER_REMOVED_FROM_SALE": self = .developerRemovedFromSale
                    case "IN_REVIEW": self = .inReview
                    case "MISSING_METADATA": self = .missingMetadata
                    case "PENDING_BINARY_APPROVAL": self = .pendingBinaryApproval
                    case "PROCESSING_CONTENT": self = .processingContent
                    case "READY_TO_SUBMIT": self = .readyToSubmit
                    case "REJECTED": self = .rejected
                    case "REMOVED_FROM_SALE": self = .removedFromSale
                    case "WAITING_FOR_REVIEW": self = .waitingForReview
                    case "WAITING_FOR_UPLOAD": self = .waitingForUpload
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// filter by attribute 'inAppPurchaseType'
                public static var inAppPurchaseType: Relation<[InAppPurchaseType]?> {
                    .init(key: "filter[inAppPurchaseType]")
                }

                /// filter by attribute 'name'
                public static var name: Relation<[String]?> {
                    .init(key: "filter[name]")
                }

                /// filter by attribute 'productId'
                public static var productId: Relation<[String]?> {
                    .init(key: "filter[productId]")
                }

                /// filter by attribute 'state'
                public static var state: Relation<[State]?> {
                    .init(key: "filter[state]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case appStoreReviewScreenshot
            case content
            case iapPriceSchedule
            case inAppPurchaseAvailability
            case inAppPurchaseLocalizations
            case promotedPurchase
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .appStoreReviewScreenshot: return "appStoreReviewScreenshot"
                case .content: return "content"
                case .iapPriceSchedule: return "iapPriceSchedule"
                case .inAppPurchaseAvailability: return "inAppPurchaseAvailability"
                case .inAppPurchaseLocalizations: return "inAppPurchaseLocalizations"
                case .promotedPurchase: return "promotedPurchase"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "appStoreReviewScreenshot": self = .appStoreReviewScreenshot
                case "content": self = .content
                case "iapPriceSchedule": self = .iapPriceSchedule
                case "inAppPurchaseAvailability": self = .inAppPurchaseAvailability
                case "inAppPurchaseLocalizations": self = .inAppPurchaseLocalizations
                case "promotedPurchase": self = .promotedPurchase
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related inAppPurchaseLocalizations returned (when they are included)
                public static var inAppPurchaseLocalizations: Relation<Int?> {
                    .init(key: "limit[inAppPurchaseLocalizations]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Sort: Hashable, Codable, RawRepresentable {
            case inAppPurchaseType
            case inAppPurchaseTypeDesc
            case name
            case nameDesc
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .inAppPurchaseType: return "inAppPurchaseType"
                case .inAppPurchaseTypeDesc: return "-inAppPurchaseType"
                case .name: return "name"
                case .nameDesc: return "-name"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "inAppPurchaseType": self = .inAppPurchaseType
                case "-inAppPurchaseType": self = .inAppPurchaseTypeDesc
                case "name": self = .name
                case "-name": self = .nameDesc
                default: self = .unknown(rawValue)
                }
            }
        }
    }
}

// swiftlint:enable all
