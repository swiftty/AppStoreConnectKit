// autogenerated

// swiftlint:disable all
import Foundation

extension V1.Apps {
    public struct GET: Endpoint {
        public typealias Response = AppsResponse

        public var path: String {
            "/v1/apps"
        }

        public var parameters: Parameters = Parameters()

        public init() {

        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "exists[gameCenterEnabledVersions]",
                             value: parameters.exists[.gameCenterEnabledVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appClips]",
                             value: parameters.fields[.appClips]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appInfos]",
                             value: parameters.fields[.appInfos]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appPreOrders]",
                             value: parameters.fields[.appPreOrders]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appPrices]",
                             value: parameters.fields[.appPrices]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersions]",
                             value: parameters.fields[.appStoreVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[apps]",
                             value: parameters.fields[.apps]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaAppLocalizations]",
                             value: parameters.fields[.betaAppLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaAppReviewDetails]",
                             value: parameters.fields[.betaAppReviewDetails]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaGroups]",
                             value: parameters.fields[.betaGroups]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaLicenseAgreements]",
                             value: parameters.fields[.betaLicenseAgreements]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[builds]",
                             value: parameters.fields[.builds]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[ciProducts]",
                             value: parameters.fields[.ciProducts]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[endUserLicenseAgreements]",
                             value: parameters.fields[.endUserLicenseAgreements]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[gameCenterEnabledVersions]",
                             value: parameters.fields[.gameCenterEnabledVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[inAppPurchases]",
                             value: parameters.fields[.inAppPurchases]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[perfPowerMetrics]",
                             value: parameters.fields[.perfPowerMetrics]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[preReleaseVersions]",
                             value: parameters.fields[.preReleaseVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[territories]",
                             value: parameters.fields[.territories]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[appStoreVersions.appStoreState]",
                             value: parameters.filter[.appStoreVersionsAppStoreState]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[appStoreVersions.platform]",
                             value: parameters.filter[.appStoreVersionsPlatform]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[appStoreVersions]",
                             value: parameters.filter[.appStoreVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[bundleId]",
                             value: parameters.filter[.bundleId]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[id]",
                             value: parameters.filter[.id]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[name]",
                             value: parameters.filter[.name]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[sku]",
                             value: parameters.filter[.sku]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[appClips]",
                             value: parameters.limit[.appClips].map { "\($0)" }),
                URLQueryItem(name: "limit[appInfos]",
                             value: parameters.limit[.appInfos].map { "\($0)" }),
                URLQueryItem(name: "limit[appStoreVersions]",
                             value: parameters.limit[.appStoreVersions].map { "\($0)" }),
                URLQueryItem(name: "limit[availableTerritories]",
                             value: parameters.limit[.availableTerritories].map { "\($0)" }),
                URLQueryItem(name: "limit[betaAppLocalizations]",
                             value: parameters.limit[.betaAppLocalizations].map { "\($0)" }),
                URLQueryItem(name: "limit[betaGroups]",
                             value: parameters.limit[.betaGroups].map { "\($0)" }),
                URLQueryItem(name: "limit[builds]",
                             value: parameters.limit[.builds].map { "\($0)" }),
                URLQueryItem(name: "limit[gameCenterEnabledVersions]",
                             value: parameters.limit[.gameCenterEnabledVersions].map { "\($0)" }),
                URLQueryItem(name: "limit[inAppPurchases]",
                             value: parameters.limit[.inAppPurchases].map { "\($0)" }),
                URLQueryItem(name: "limit[preReleaseVersions]",
                             value: parameters.limit[.preReleaseVersions].map { "\($0)" }),
                URLQueryItem(name: "limit[prices]",
                             value: parameters.limit[.prices].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" }),
                URLQueryItem(name: "sort",
                             value: parameters.sort?.map { "\($0)" }.joined(separator: ","))
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of Apps as `AppsResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(AppsResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.Apps.GET {
    public struct Parameters: Hashable {
        public var exists: Exists = Exists()

        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        /// comma-separated list of sort expressions; resources will be sorted as specified
        public var sort: [Sort]?

        public struct Exists: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// filter by existence or non-existence of related 'gameCenterEnabledVersions'
                public static var gameCenterEnabledVersions: Relation<[String]?> {
                    .init(key: "exists[gameCenterEnabledVersions]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppClips: String, Hashable, Codable {
                case app
                case appClipAdvancedExperiences
                case appClipDefaultExperiences
                case bundleId
            }

            public enum AppInfos: String, Hashable, Codable {
                case ageRatingDeclaration
                case app
                case appInfoLocalizations
                case appStoreAgeRating
                case appStoreState
                case brazilAgeRating
                case kidsAgeBand
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
            }

            public enum AppPreOrders: String, Hashable, Codable {
                case app
                case appReleaseDate
                case preOrderAvailableDate
            }

            public enum AppPrices: String, Hashable, Codable {
                case app
                case priceTier
            }

            public enum AppStoreVersions: String, Hashable, Codable {
                case ageRatingDeclaration
                case app
                case appClipDefaultExperience
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum Apps: String, Hashable, Codable {
                case appClips
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleId
                case ciProduct
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum BetaAppLocalizations: String, Hashable, Codable {
                case app
                case description
                case feedbackEmail
                case locale
                case marketingUrl
                case privacyPolicyUrl
                case tvOsPrivacyPolicy
            }

            public enum BetaAppReviewDetails: String, Hashable, Codable {
                case app
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum BetaGroups: String, Hashable, Codable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case hasAccessToAllBuilds
                case iosBuildsAvailableForAppleSiliconMac
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkId
                case publicLinkLimit
                case publicLinkLimitEnabled
            }

            public enum BetaLicenseAgreements: String, Hashable, Codable {
                case agreementText
                case app
            }

            public enum Builds: String, Hashable, Codable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildAudienceType
                case buildBetaDetail
                case buildBundles
                case computedMinMacOsVersion
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case lsMinimumSystemVersion
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum CiProducts: String, Hashable, Codable {
                case additionalRepositories
                case app
                case buildRuns
                case bundleId
                case createdDate
                case name
                case primaryRepositories
                case productType
                case workflows
            }

            public enum EndUserLicenseAgreements: String, Hashable, Codable {
                case agreementText
                case app
                case territories
            }

            public enum GameCenterEnabledVersions: String, Hashable, Codable {
                case app
                case compatibleVersions
                case iconAsset
                case platform
                case versionString
            }

            public enum InAppPurchases: String, Hashable, Codable {
                case apps
                case inAppPurchaseType
                case productId
                case referenceName
                case state
            }

            public enum PerfPowerMetrics: String, Hashable, Codable {
                case deviceType
                case metricType
                case platform
            }

            public enum PreReleaseVersions: String, Hashable, Codable {
                case app
                case builds
                case platform
                case version
            }

            public enum Territories: String, Hashable, Codable {
                case currency
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type appClips
                public static var appClips: Relation<[AppClips]?> {
                    .init(key: "fields[appClips]")
                }

                /// the fields to include for returned resources of type appInfos
                public static var appInfos: Relation<[AppInfos]?> {
                    .init(key: "fields[appInfos]")
                }

                /// the fields to include for returned resources of type appPreOrders
                public static var appPreOrders: Relation<[AppPreOrders]?> {
                    .init(key: "fields[appPreOrders]")
                }

                /// the fields to include for returned resources of type appPrices
                public static var appPrices: Relation<[AppPrices]?> {
                    .init(key: "fields[appPrices]")
                }

                /// the fields to include for returned resources of type appStoreVersions
                public static var appStoreVersions: Relation<[AppStoreVersions]?> {
                    .init(key: "fields[appStoreVersions]")
                }

                /// the fields to include for returned resources of type apps
                public static var apps: Relation<[Apps]?> {
                    .init(key: "fields[apps]")
                }

                /// the fields to include for returned resources of type betaAppLocalizations
                public static var betaAppLocalizations: Relation<[BetaAppLocalizations]?> {
                    .init(key: "fields[betaAppLocalizations]")
                }

                /// the fields to include for returned resources of type betaAppReviewDetails
                public static var betaAppReviewDetails: Relation<[BetaAppReviewDetails]?> {
                    .init(key: "fields[betaAppReviewDetails]")
                }

                /// the fields to include for returned resources of type betaGroups
                public static var betaGroups: Relation<[BetaGroups]?> {
                    .init(key: "fields[betaGroups]")
                }

                /// the fields to include for returned resources of type betaLicenseAgreements
                public static var betaLicenseAgreements: Relation<[BetaLicenseAgreements]?> {
                    .init(key: "fields[betaLicenseAgreements]")
                }

                /// the fields to include for returned resources of type builds
                public static var builds: Relation<[Builds]?> {
                    .init(key: "fields[builds]")
                }

                /// the fields to include for returned resources of type ciProducts
                public static var ciProducts: Relation<[CiProducts]?> {
                    .init(key: "fields[ciProducts]")
                }

                /// the fields to include for returned resources of type endUserLicenseAgreements
                public static var endUserLicenseAgreements: Relation<[EndUserLicenseAgreements]?> {
                    .init(key: "fields[endUserLicenseAgreements]")
                }

                /// the fields to include for returned resources of type gameCenterEnabledVersions
                public static var gameCenterEnabledVersions: Relation<[GameCenterEnabledVersions]?> {
                    .init(key: "fields[gameCenterEnabledVersions]")
                }

                /// the fields to include for returned resources of type inAppPurchases
                public static var inAppPurchases: Relation<[InAppPurchases]?> {
                    .init(key: "fields[inAppPurchases]")
                }

                /// the fields to include for returned resources of type perfPowerMetrics
                public static var perfPowerMetrics: Relation<[PerfPowerMetrics]?> {
                    .init(key: "fields[perfPowerMetrics]")
                }

                /// the fields to include for returned resources of type preReleaseVersions
                public static var preReleaseVersions: Relation<[PreReleaseVersions]?> {
                    .init(key: "fields[preReleaseVersions]")
                }

                /// the fields to include for returned resources of type territories
                public static var territories: Relation<[Territories]?> {
                    .init(key: "fields[territories]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppStoreVersionsAppStoreState: String, Hashable, Codable {
                case developerRejected = "DEVELOPER_REJECTED"
                case developerRemovedFromSale = "DEVELOPER_REMOVED_FROM_SALE"
                case invalidBinary = "INVALID_BINARY"
                case inReview = "IN_REVIEW"
                case metadataRejected = "METADATA_REJECTED"
                case pendingAppleRelease = "PENDING_APPLE_RELEASE"
                case pendingContract = "PENDING_CONTRACT"
                case pendingDeveloperRelease = "PENDING_DEVELOPER_RELEASE"
                case preorderReadyForSale = "PREORDER_READY_FOR_SALE"
                case prepareForSubmission = "PREPARE_FOR_SUBMISSION"
                case processingForAppStore = "PROCESSING_FOR_APP_STORE"
                case readyForSale = "READY_FOR_SALE"
                case rejected = "REJECTED"
                case removedFromSale = "REMOVED_FROM_SALE"
                case replacedWithNewVersion = "REPLACED_WITH_NEW_VERSION"
                case waitingForExportCompliance = "WAITING_FOR_EXPORT_COMPLIANCE"
                case waitingForReview = "WAITING_FOR_REVIEW"
            }

            public enum AppStoreVersionsPlatform: String, Hashable, Codable {
                case iOS = "IOS"
                case macOS = "MAC_OS"
                case tvOS = "TV_OS"
            }

            public struct Relation<T>: Hashable {
                /// filter by attribute 'appStoreVersions.appStoreState'
                public static var appStoreVersionsAppStoreState: Relation<[AppStoreVersionsAppStoreState]?> {
                    .init(key: "filter[appStoreVersions.appStoreState]")
                }

                /// filter by attribute 'appStoreVersions.platform'
                public static var appStoreVersionsPlatform: Relation<[AppStoreVersionsPlatform]?> {
                    .init(key: "filter[appStoreVersions.platform]")
                }

                /// filter by id(s) of related 'appStoreVersions'
                public static var appStoreVersions: Relation<[String]?> {
                    .init(key: "filter[appStoreVersions]")
                }

                /// filter by attribute 'bundleId'
                public static var bundleId: Relation<[String]?> {
                    .init(key: "filter[bundleId]")
                }

                /// filter by id(s)
                public static var id: Relation<[String]?> {
                    .init(key: "filter[id]")
                }

                /// filter by attribute 'name'
                public static var name: Relation<[String]?> {
                    .init(key: "filter[name]")
                }

                /// filter by attribute 'sku'
                public static var sku: Relation<[String]?> {
                    .init(key: "filter[sku]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: String, Hashable, Codable {
            case appClips
            case appInfos
            case appStoreVersions
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case builds
            case ciProduct
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case preOrder
            case preReleaseVersions
            case prices
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related appClips returned (when they are included)
                public static var appClips: Relation<Int?> {
                    .init(key: "limit[appClips]")
                }

                /// maximum number of related appInfos returned (when they are included)
                public static var appInfos: Relation<Int?> {
                    .init(key: "limit[appInfos]")
                }

                /// maximum number of related appStoreVersions returned (when they are included)
                public static var appStoreVersions: Relation<Int?> {
                    .init(key: "limit[appStoreVersions]")
                }

                /// maximum number of related availableTerritories returned (when they are included)
                public static var availableTerritories: Relation<Int?> {
                    .init(key: "limit[availableTerritories]")
                }

                /// maximum number of related betaAppLocalizations returned (when they are included)
                public static var betaAppLocalizations: Relation<Int?> {
                    .init(key: "limit[betaAppLocalizations]")
                }

                /// maximum number of related betaGroups returned (when they are included)
                public static var betaGroups: Relation<Int?> {
                    .init(key: "limit[betaGroups]")
                }

                /// maximum number of related builds returned (when they are included)
                public static var builds: Relation<Int?> {
                    .init(key: "limit[builds]")
                }

                /// maximum number of related gameCenterEnabledVersions returned (when they are included)
                public static var gameCenterEnabledVersions: Relation<Int?> {
                    .init(key: "limit[gameCenterEnabledVersions]")
                }

                /// maximum number of related inAppPurchases returned (when they are included)
                public static var inAppPurchases: Relation<Int?> {
                    .init(key: "limit[inAppPurchases]")
                }

                /// maximum number of related preReleaseVersions returned (when they are included)
                public static var preReleaseVersions: Relation<Int?> {
                    .init(key: "limit[preReleaseVersions]")
                }

                /// maximum number of related prices returned (when they are included)
                public static var prices: Relation<Int?> {
                    .init(key: "limit[prices]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Sort: String, Hashable, Codable {
            case bundleIdDesc = "-bundleId"
            case nameDesc = "-name"
            case skuDesc = "-sku"
            case bundleId
            case name
            case sku
        }
    }
}

// swiftlint:enable all
