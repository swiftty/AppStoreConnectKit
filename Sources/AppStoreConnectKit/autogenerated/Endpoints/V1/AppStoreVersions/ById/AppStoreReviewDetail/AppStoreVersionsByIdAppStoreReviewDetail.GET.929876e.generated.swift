// autogenerated

// swiftlint:disable all
import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension V1.AppStoreVersions.ById.AppStoreReviewDetail {
    public struct GET: Endpoint {
        public typealias Response = AppStoreReviewDetailResponse

        public var path: String {
            "/v1/appStoreVersions/\(id)/appStoreReviewDetail"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[appStoreReviewAttachments]",
                             value: parameters.fields[.appStoreReviewAttachments]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreReviewDetails]",
                             value: parameters.fields[.appStoreReviewDetails]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersions]",
                             value: parameters.fields[.appStoreVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[appStoreReviewAttachments]",
                             value: parameters.limit[.appStoreReviewAttachments].map { "\($0)" })
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, Single AppStoreReviewDetail as `AppStoreReviewDetailResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(AppStoreReviewDetailResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.AppStoreVersions.ById.AppStoreReviewDetail.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        public var limit: Limit = Limit()

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppStoreReviewAttachments: Hashable, Codable, RawRepresentable {
                case appStoreReviewDetail
                case assetDeliveryState
                case fileName
                case fileSize
                case sourceFileChecksum
                case uploadOperations
                case uploaded
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appStoreReviewDetail: return "appStoreReviewDetail"
                    case .assetDeliveryState: return "assetDeliveryState"
                    case .fileName: return "fileName"
                    case .fileSize: return "fileSize"
                    case .sourceFileChecksum: return "sourceFileChecksum"
                    case .uploadOperations: return "uploadOperations"
                    case .uploaded: return "uploaded"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "appStoreReviewDetail": self = .appStoreReviewDetail
                    case "assetDeliveryState": self = .assetDeliveryState
                    case "fileName": self = .fileName
                    case "fileSize": self = .fileSize
                    case "sourceFileChecksum": self = .sourceFileChecksum
                    case "uploadOperations": self = .uploadOperations
                    case "uploaded": self = .uploaded
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppStoreReviewDetails: Hashable, Codable, RawRepresentable {
                case appStoreReviewAttachments
                case appStoreVersion
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appStoreReviewAttachments: return "appStoreReviewAttachments"
                    case .appStoreVersion: return "appStoreVersion"
                    case .contactEmail: return "contactEmail"
                    case .contactFirstName: return "contactFirstName"
                    case .contactLastName: return "contactLastName"
                    case .contactPhone: return "contactPhone"
                    case .demoAccountName: return "demoAccountName"
                    case .demoAccountPassword: return "demoAccountPassword"
                    case .demoAccountRequired: return "demoAccountRequired"
                    case .notes: return "notes"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "appStoreReviewAttachments": self = .appStoreReviewAttachments
                    case "appStoreVersion": self = .appStoreVersion
                    case "contactEmail": self = .contactEmail
                    case "contactFirstName": self = .contactFirstName
                    case "contactLastName": self = .contactLastName
                    case "contactPhone": self = .contactPhone
                    case "demoAccountName": self = .demoAccountName
                    case "demoAccountPassword": self = .demoAccountPassword
                    case "demoAccountRequired": self = .demoAccountRequired
                    case "notes": self = .notes
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppStoreVersions: Hashable, Codable, RawRepresentable {
                case ageRatingDeclaration
                case app
                case appClipDefaultExperience
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionExperiments
                case appStoreVersionExperimentsV2
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case customerReviews
                case downloadable
                case earliestReleaseDate
                case platform
                case releaseType
                case routingAppCoverage
                case versionString
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .ageRatingDeclaration: return "ageRatingDeclaration"
                    case .app: return "app"
                    case .appClipDefaultExperience: return "appClipDefaultExperience"
                    case .appStoreReviewDetail: return "appStoreReviewDetail"
                    case .appStoreState: return "appStoreState"
                    case .appStoreVersionExperiments: return "appStoreVersionExperiments"
                    case .appStoreVersionExperimentsV2: return "appStoreVersionExperimentsV2"
                    case .appStoreVersionLocalizations: return "appStoreVersionLocalizations"
                    case .appStoreVersionPhasedRelease: return "appStoreVersionPhasedRelease"
                    case .appStoreVersionSubmission: return "appStoreVersionSubmission"
                    case .build: return "build"
                    case .copyright: return "copyright"
                    case .createdDate: return "createdDate"
                    case .customerReviews: return "customerReviews"
                    case .downloadable: return "downloadable"
                    case .earliestReleaseDate: return "earliestReleaseDate"
                    case .platform: return "platform"
                    case .releaseType: return "releaseType"
                    case .routingAppCoverage: return "routingAppCoverage"
                    case .versionString: return "versionString"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "ageRatingDeclaration": self = .ageRatingDeclaration
                    case "app": self = .app
                    case "appClipDefaultExperience": self = .appClipDefaultExperience
                    case "appStoreReviewDetail": self = .appStoreReviewDetail
                    case "appStoreState": self = .appStoreState
                    case "appStoreVersionExperiments": self = .appStoreVersionExperiments
                    case "appStoreVersionExperimentsV2": self = .appStoreVersionExperimentsV2
                    case "appStoreVersionLocalizations": self = .appStoreVersionLocalizations
                    case "appStoreVersionPhasedRelease": self = .appStoreVersionPhasedRelease
                    case "appStoreVersionSubmission": self = .appStoreVersionSubmission
                    case "build": self = .build
                    case "copyright": self = .copyright
                    case "createdDate": self = .createdDate
                    case "customerReviews": self = .customerReviews
                    case "downloadable": self = .downloadable
                    case "earliestReleaseDate": self = .earliestReleaseDate
                    case "platform": self = .platform
                    case "releaseType": self = .releaseType
                    case "routingAppCoverage": self = .routingAppCoverage
                    case "versionString": self = .versionString
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type appStoreReviewAttachments
                public static var appStoreReviewAttachments: Relation<[AppStoreReviewAttachments]?> {
                    .init(key: "fields[appStoreReviewAttachments]")
                }

                /// the fields to include for returned resources of type appStoreReviewDetails
                public static var appStoreReviewDetails: Relation<[AppStoreReviewDetails]?> {
                    .init(key: "fields[appStoreReviewDetails]")
                }

                /// the fields to include for returned resources of type appStoreVersions
                public static var appStoreVersions: Relation<[AppStoreVersions]?> {
                    .init(key: "fields[appStoreVersions]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case appStoreReviewAttachments
            case appStoreVersion
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .appStoreReviewAttachments: return "appStoreReviewAttachments"
                case .appStoreVersion: return "appStoreVersion"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "appStoreReviewAttachments": self = .appStoreReviewAttachments
                case "appStoreVersion": self = .appStoreVersion
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related appStoreReviewAttachments returned (when they are included)
                public static var appStoreReviewAttachments: Relation<Int?> {
                    .init(key: "limit[appStoreReviewAttachments]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }
    }
}

// swiftlint:enable all
