// autogenerated

// swiftlint:disable all
import Foundation

extension V1.AppStoreVersions.ById {
    public struct GET: Endpoint {
        public typealias Response = AppStoreVersionResponse

        public var path: String {
            "/v1/appStoreVersions/\(id)"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[ageRatingDeclarations]",
                             value: parameters.fields[.ageRatingDeclarations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appClipDefaultExperiences]",
                             value: parameters.fields[.appClipDefaultExperiences]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreReviewDetails]",
                             value: parameters.fields[.appStoreReviewDetails]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersionLocalizations]",
                             value: parameters.fields[.appStoreVersionLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersionPhasedReleases]",
                             value: parameters.fields[.appStoreVersionPhasedReleases]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersionSubmissions]",
                             value: parameters.fields[.appStoreVersionSubmissions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersions]",
                             value: parameters.fields[.appStoreVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[builds]",
                             value: parameters.fields[.builds]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[idfaDeclarations]",
                             value: parameters.fields[.idfaDeclarations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[routingAppCoverages]",
                             value: parameters.fields[.routingAppCoverages]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[appStoreVersionLocalizations]",
                             value: parameters.limit[.appStoreVersionLocalizations].map { "\($0)" })
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, Single AppStoreVersion as `AppStoreVersionResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(AppStoreVersionResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.AppStoreVersions.ById.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        public var limit: Limit = Limit()

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AgeRatingDeclarations: String, Hashable, Codable {
                case alcoholTobaccoOrDrugUseOrReferences
                case contests
                case gambling
                case gamblingAndContests
                case gamblingSimulated
                case horrorOrFearThemes
                case kidsAgeBand
                case matureOrSuggestiveThemes
                case medicalOrTreatmentInformation
                case profanityOrCrudeHumor
                case seventeenPlus
                case sexualContentGraphicAndNudity
                case sexualContentOrNudity
                case unrestrictedWebAccess
                case violenceCartoonOrFantasy
                case violenceRealistic
                case violenceRealisticProlongedGraphicOrSadistic
            }

            public enum AppClipDefaultExperiences: String, Hashable, Codable {
                case action
                case appClip
                case appClipAppStoreReviewDetail
                case appClipDefaultExperienceLocalizations
                case appClipDefaultExperienceTemplate
                case releaseWithAppStoreVersion
            }

            public enum AppStoreReviewDetails: String, Hashable, Codable {
                case appStoreReviewAttachments
                case appStoreVersion
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum AppStoreVersionLocalizations: String, Hashable, Codable {
                case appPreviewSets
                case appScreenshotSets
                case appStoreVersion
                case description
                case keywords
                case locale
                case marketingUrl
                case promotionalText
                case supportUrl
                case whatsNew
            }

            public enum AppStoreVersionPhasedReleases: String, Hashable, Codable {
                case appStoreVersion
                case currentDayNumber
                case phasedReleaseState
                case startDate
                case totalPauseDuration
            }

            public enum AppStoreVersionSubmissions: String, Hashable, Codable {
                case appStoreVersion
            }

            public enum AppStoreVersions: String, Hashable, Codable {
                case ageRatingDeclaration
                case app
                case appClipDefaultExperience
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum Builds: String, Hashable, Codable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildAudienceType
                case buildBetaDetail
                case buildBundles
                case computedMinMacOsVersion
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case lsMinimumSystemVersion
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum IdfaDeclarations: String, Hashable, Codable {
                case appStoreVersion
                case attributesActionWithPreviousAd
                case attributesAppInstallationToPreviousAd
                case honorsLimitedAdTracking
                case servesAds
            }

            public enum RoutingAppCoverages: String, Hashable, Codable {
                case appStoreVersion
                case assetDeliveryState
                case fileName
                case fileSize
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type ageRatingDeclarations
                public static var ageRatingDeclarations: Relation<[AgeRatingDeclarations]?> {
                    .init(key: "fields[ageRatingDeclarations]")
                }

                /// the fields to include for returned resources of type appClipDefaultExperiences
                public static var appClipDefaultExperiences: Relation<[AppClipDefaultExperiences]?> {
                    .init(key: "fields[appClipDefaultExperiences]")
                }

                /// the fields to include for returned resources of type appStoreReviewDetails
                public static var appStoreReviewDetails: Relation<[AppStoreReviewDetails]?> {
                    .init(key: "fields[appStoreReviewDetails]")
                }

                /// the fields to include for returned resources of type appStoreVersionLocalizations
                public static var appStoreVersionLocalizations: Relation<[AppStoreVersionLocalizations]?> {
                    .init(key: "fields[appStoreVersionLocalizations]")
                }

                /// the fields to include for returned resources of type appStoreVersionPhasedReleases
                public static var appStoreVersionPhasedReleases: Relation<[AppStoreVersionPhasedReleases]?> {
                    .init(key: "fields[appStoreVersionPhasedReleases]")
                }

                /// the fields to include for returned resources of type appStoreVersionSubmissions
                public static var appStoreVersionSubmissions: Relation<[AppStoreVersionSubmissions]?> {
                    .init(key: "fields[appStoreVersionSubmissions]")
                }

                /// the fields to include for returned resources of type appStoreVersions
                public static var appStoreVersions: Relation<[AppStoreVersions]?> {
                    .init(key: "fields[appStoreVersions]")
                }

                /// the fields to include for returned resources of type builds
                public static var builds: Relation<[Builds]?> {
                    .init(key: "fields[builds]")
                }

                /// the fields to include for returned resources of type idfaDeclarations
                public static var idfaDeclarations: Relation<[IdfaDeclarations]?> {
                    .init(key: "fields[idfaDeclarations]")
                }

                /// the fields to include for returned resources of type routingAppCoverages
                public static var routingAppCoverages: Relation<[RoutingAppCoverages]?> {
                    .init(key: "fields[routingAppCoverages]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: String, Hashable, Codable {
            case ageRatingDeclaration
            case app
            case appClipDefaultExperience
            case appStoreReviewDetail
            case appStoreVersionLocalizations
            case appStoreVersionPhasedRelease
            case appStoreVersionSubmission
            case build
            case idfaDeclaration
            case routingAppCoverage
        }

        public struct Limit: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related appStoreVersionLocalizations returned (when they are included)
                public static var appStoreVersionLocalizations: Relation<Int?> {
                    .init(key: "limit[appStoreVersionLocalizations]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }
    }
}

// swiftlint:enable all
