// autogenerated

// swiftlint:disable all
import Foundation

extension V1.CiBuildRuns.ById.Builds {
    public struct GET: Endpoint {
        public typealias Response = BuildsResponse

        public var path: String {
            "/v1/ciBuildRuns/\(id)/builds"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[betaBuildLocalizations]",
                             value: parameters.fields[.betaBuildLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaTesters]",
                             value: parameters.fields[.betaTesters]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[buildBundles]",
                             value: parameters.fields[.buildBundles]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[buildIcons]",
                             value: parameters.fields[.buildIcons]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[builds]",
                             value: parameters.fields[.builds]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[appStoreVersion]",
                             value: parameters.filter[.appStoreVersion]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[app]",
                             value: parameters.filter[.app]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[betaAppReviewSubmission.betaReviewState]",
                             value: parameters.filter[.betaAppReviewSubmissionBetaReviewState]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[betaGroups]",
                             value: parameters.filter[.betaGroups]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[buildAudienceType]",
                             value: parameters.filter[.buildAudienceType]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[expired]",
                             value: parameters.filter[.expired]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[id]",
                             value: parameters.filter[.id]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[preReleaseVersion.platform]",
                             value: parameters.filter[.preReleaseVersionPlatform]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[preReleaseVersion.version]",
                             value: parameters.filter[.preReleaseVersionVersion]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[preReleaseVersion]",
                             value: parameters.filter[.preReleaseVersion]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[processingState]",
                             value: parameters.filter[.processingState]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[usesNonExemptEncryption]",
                             value: parameters.filter[.usesNonExemptEncryption]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[version]",
                             value: parameters.filter[.version]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[betaBuildLocalizations]",
                             value: parameters.limit[.betaBuildLocalizations].map { "\($0)" }),
                URLQueryItem(name: "limit[buildBundles]",
                             value: parameters.limit[.buildBundles].map { "\($0)" }),
                URLQueryItem(name: "limit[icons]",
                             value: parameters.limit[.icons].map { "\($0)" }),
                URLQueryItem(name: "limit[individualTesters]",
                             value: parameters.limit[.individualTesters].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" }),
                URLQueryItem(name: "sort",
                             value: parameters.sort?.map { "\($0)" }.joined(separator: ","))
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of related resources as `BuildsResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(BuildsResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.CiBuildRuns.ById.Builds.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        /// comma-separated list of sort expressions; resources will be sorted as specified
        public var sort: [Sort]?

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum BetaBuildLocalizations: String, Hashable, Codable {
                case build
                case locale
                case whatsNew
            }

            public enum BetaTesters: String, Hashable, Codable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
            }

            public enum BuildBundles: String, Hashable, Codable {
                case appClipDomainCacheStatus
                case appClipDomainDebugStatus
                case betaAppClipInvocations
                case buildBundleFileSizes
                case bundleId
                case bundleType
                case dSYMUrl
                case deviceProtocols
                case entitlements
                case fileName
                case hasOnDemandResources
                case hasPrerenderedIcon
                case hasSirikit
                case includesSymbols
                case isIosBuildMacAppStoreCompatible
                case locales
                case platformBuild
                case requiredCapabilities
                case sdkBuild
                case supportedArchitectures
                case usesLocationServices
            }

            public enum BuildIcons: String, Hashable, Codable {
                case iconAsset
                case iconType
            }

            public enum Builds: String, Hashable, Codable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildAudienceType
                case buildBetaDetail
                case buildBundles
                case computedMinMacOsVersion
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case lsMinimumSystemVersion
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type betaBuildLocalizations
                public static var betaBuildLocalizations: Relation<[BetaBuildLocalizations]?> {
                    .init(key: "fields[betaBuildLocalizations]")
                }

                /// the fields to include for returned resources of type betaTesters
                public static var betaTesters: Relation<[BetaTesters]?> {
                    .init(key: "fields[betaTesters]")
                }

                /// the fields to include for returned resources of type buildBundles
                public static var buildBundles: Relation<[BuildBundles]?> {
                    .init(key: "fields[buildBundles]")
                }

                /// the fields to include for returned resources of type buildIcons
                public static var buildIcons: Relation<[BuildIcons]?> {
                    .init(key: "fields[buildIcons]")
                }

                /// the fields to include for returned resources of type builds
                public static var builds: Relation<[Builds]?> {
                    .init(key: "fields[builds]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum BetaAppReviewSubmissionBetaReviewState: String, Hashable, Codable {
                case approved = "APPROVED"
                case inReview = "IN_REVIEW"
                case rejected = "REJECTED"
                case waitingForReview = "WAITING_FOR_REVIEW"
            }

            public enum BuildAudienceType: String, Hashable, Codable {
                case appStoreEligible = "APP_STORE_ELIGIBLE"
                case internalOnly = "INTERNAL_ONLY"
            }

            public enum PreReleaseVersionPlatform: String, Hashable, Codable {
                case iOS = "IOS"
                case macOS = "MAC_OS"
                case tvOS = "TV_OS"
            }

            public enum ProcessingState: String, Hashable, Codable {
                case failed = "FAILED"
                case invalid = "INVALID"
                case processing = "PROCESSING"
                case valid = "VALID"
            }

            public struct Relation<T>: Hashable {
                /// filter by id(s) of related 'appStoreVersion'
                public static var appStoreVersion: Relation<[String]?> {
                    .init(key: "filter[appStoreVersion]")
                }

                /// filter by id(s) of related 'app'
                public static var app: Relation<[String]?> {
                    .init(key: "filter[app]")
                }

                /// filter by attribute 'betaAppReviewSubmission.betaReviewState'
                public static var betaAppReviewSubmissionBetaReviewState: Relation<[BetaAppReviewSubmissionBetaReviewState]?> {
                    .init(key: "filter[betaAppReviewSubmission.betaReviewState]")
                }

                /// filter by id(s) of related 'betaGroups'
                public static var betaGroups: Relation<[String]?> {
                    .init(key: "filter[betaGroups]")
                }

                /// filter by attribute 'buildAudienceType'
                public static var buildAudienceType: Relation<[BuildAudienceType]?> {
                    .init(key: "filter[buildAudienceType]")
                }

                /// filter by attribute 'expired'
                public static var expired: Relation<[String]?> {
                    .init(key: "filter[expired]")
                }

                /// filter by id(s)
                public static var id: Relation<[String]?> {
                    .init(key: "filter[id]")
                }

                /// filter by attribute 'preReleaseVersion.platform'
                public static var preReleaseVersionPlatform: Relation<[PreReleaseVersionPlatform]?> {
                    .init(key: "filter[preReleaseVersion.platform]")
                }

                /// filter by attribute 'preReleaseVersion.version'
                public static var preReleaseVersionVersion: Relation<[String]?> {
                    .init(key: "filter[preReleaseVersion.version]")
                }

                /// filter by id(s) of related 'preReleaseVersion'
                public static var preReleaseVersion: Relation<[String]?> {
                    .init(key: "filter[preReleaseVersion]")
                }

                /// filter by attribute 'processingState'
                public static var processingState: Relation<[ProcessingState]?> {
                    .init(key: "filter[processingState]")
                }

                /// filter by attribute 'usesNonExemptEncryption'
                public static var usesNonExemptEncryption: Relation<[String]?> {
                    .init(key: "filter[usesNonExemptEncryption]")
                }

                /// filter by attribute 'version'
                public static var version: Relation<[String]?> {
                    .init(key: "filter[version]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: String, Hashable, Codable {
            case betaBuildLocalizations
            case buildBundles
            case icons
            case individualTesters
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related betaBuildLocalizations returned (when they are included)
                public static var betaBuildLocalizations: Relation<Int?> {
                    .init(key: "limit[betaBuildLocalizations]")
                }

                /// maximum number of related buildBundles returned (when they are included)
                public static var buildBundles: Relation<Int?> {
                    .init(key: "limit[buildBundles]")
                }

                /// maximum number of related icons returned (when they are included)
                public static var icons: Relation<Int?> {
                    .init(key: "limit[icons]")
                }

                /// maximum number of related individualTesters returned (when they are included)
                public static var individualTesters: Relation<Int?> {
                    .init(key: "limit[individualTesters]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Sort: String, Hashable, Codable {
            case preReleaseVersionDesc = "-preReleaseVersion"
            case uploadedDateDesc = "-uploadedDate"
            case versionDesc = "-version"
            case preReleaseVersion
            case uploadedDate
            case version
        }
    }
}

// swiftlint:enable all
