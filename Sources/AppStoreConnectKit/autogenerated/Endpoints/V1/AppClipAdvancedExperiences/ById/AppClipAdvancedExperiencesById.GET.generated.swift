// autogenerated

// swiftlint:disable all
import Foundation

extension V1.AppClipAdvancedExperiences.ById {
    public struct GET: Endpoint {
        public typealias Response = AppClipAdvancedExperienceResponse

        public var path: String {
            "/v1/appClipAdvancedExperiences/\(id)"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[appClipAdvancedExperiences]",
                             value: parameters.fields[.appClipAdvancedExperiences]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[localizations]",
                             value: parameters.limit[.localizations].map { "\($0)" })
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, Single AppClipAdvancedExperience as `AppClipAdvancedExperienceResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(AppClipAdvancedExperienceResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.AppClipAdvancedExperiences.ById.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        public var limit: Limit = Limit()

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppClipAdvancedExperiences: Hashable, Codable, RawRepresentable {
                case action
                case appClip
                case businessCategory
                case defaultLanguage
                case headerImage
                case isPoweredBy
                case link
                case localizations
                case place
                case placeStatus
                case removed
                case status
                case version
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .action: return "action"
                    case .appClip: return "appClip"
                    case .businessCategory: return "businessCategory"
                    case .defaultLanguage: return "defaultLanguage"
                    case .headerImage: return "headerImage"
                    case .isPoweredBy: return "isPoweredBy"
                    case .link: return "link"
                    case .localizations: return "localizations"
                    case .place: return "place"
                    case .placeStatus: return "placeStatus"
                    case .removed: return "removed"
                    case .status: return "status"
                    case .version: return "version"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "action": self = .action
                    case "appClip": self = .appClip
                    case "businessCategory": self = .businessCategory
                    case "defaultLanguage": self = .defaultLanguage
                    case "headerImage": self = .headerImage
                    case "isPoweredBy": self = .isPoweredBy
                    case "link": self = .link
                    case "localizations": self = .localizations
                    case "place": self = .place
                    case "placeStatus": self = .placeStatus
                    case "removed": self = .removed
                    case "status": self = .status
                    case "version": self = .version
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type appClipAdvancedExperiences
                public static var appClipAdvancedExperiences: Relation<[AppClipAdvancedExperiences]?> {
                    .init(key: "fields[appClipAdvancedExperiences]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case appClip
            case headerImage
            case localizations
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .appClip: return "appClip"
                case .headerImage: return "headerImage"
                case .localizations: return "localizations"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "appClip": self = .appClip
                case "headerImage": self = .headerImage
                case "localizations": self = .localizations
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related localizations returned (when they are included)
                public static var localizations: Relation<Int?> {
                    .init(key: "limit[localizations]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }
    }
}

// swiftlint:enable all
