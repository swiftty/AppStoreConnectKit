// autogenerated

// swiftlint:disable all
import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension V1.Builds {
    public struct GET: Endpoint {
        public typealias Response = BuildsResponse

        public var path: String {
            "/v1/builds"
        }

        public var parameters: Parameters = Parameters()

        public init() {

        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[appEncryptionDeclarations]",
                             value: parameters.fields[.appEncryptionDeclarations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appStoreVersions]",
                             value: parameters.fields[.appStoreVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[apps]",
                             value: parameters.fields[.apps]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaAppReviewSubmissions]",
                             value: parameters.fields[.betaAppReviewSubmissions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaBuildLocalizations]",
                             value: parameters.fields[.betaBuildLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaTesters]",
                             value: parameters.fields[.betaTesters]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[buildBetaDetails]",
                             value: parameters.fields[.buildBetaDetails]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[buildIcons]",
                             value: parameters.fields[.buildIcons]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[builds]",
                             value: parameters.fields[.builds]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[diagnosticSignatures]",
                             value: parameters.fields[.diagnosticSignatures]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[perfPowerMetrics]",
                             value: parameters.fields[.perfPowerMetrics]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[preReleaseVersions]",
                             value: parameters.fields[.preReleaseVersions]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[appStoreVersion]",
                             value: parameters.filter[.appStoreVersion]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[app]",
                             value: parameters.filter[.app]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[betaAppReviewSubmission.betaReviewState]",
                             value: parameters.filter[.betaAppReviewSubmissionBetaReviewState]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[betaGroups]",
                             value: parameters.filter[.betaGroups]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[buildAudienceType]",
                             value: parameters.filter[.buildAudienceType]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[expired]",
                             value: parameters.filter[.expired]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[id]",
                             value: parameters.filter[.id]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[preReleaseVersion.platform]",
                             value: parameters.filter[.preReleaseVersionPlatform]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[preReleaseVersion.version]",
                             value: parameters.filter[.preReleaseVersionVersion]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[preReleaseVersion]",
                             value: parameters.filter[.preReleaseVersion]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[processingState]",
                             value: parameters.filter[.processingState]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[usesNonExemptEncryption]",
                             value: parameters.filter[.usesNonExemptEncryption]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[version]",
                             value: parameters.filter[.version]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[betaBuildLocalizations]",
                             value: parameters.limit[.betaBuildLocalizations].map { "\($0)" }),
                URLQueryItem(name: "limit[buildBundles]",
                             value: parameters.limit[.buildBundles].map { "\($0)" }),
                URLQueryItem(name: "limit[icons]",
                             value: parameters.limit[.icons].map { "\($0)" }),
                URLQueryItem(name: "limit[individualTesters]",
                             value: parameters.limit[.individualTesters].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" }),
                URLQueryItem(name: "sort",
                             value: parameters.sort?.map { "\($0)" }.joined(separator: ","))
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of Builds as `BuildsResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(BuildsResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.Builds.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        /// comma-separated list of sort expressions; resources will be sorted as specified
        public var sort: [Sort]?

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppEncryptionDeclarations: Hashable, Codable, RawRepresentable {
                case app
                case appEncryptionDeclarationState
                case availableOnFrenchStore
                case builds
                case codeValue
                case containsProprietaryCryptography
                case containsThirdPartyCryptography
                case documentName
                case documentType
                case documentUrl
                case exempt
                case platform
                case uploadedDate
                case usesEncryption
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .appEncryptionDeclarationState: return "appEncryptionDeclarationState"
                    case .availableOnFrenchStore: return "availableOnFrenchStore"
                    case .builds: return "builds"
                    case .codeValue: return "codeValue"
                    case .containsProprietaryCryptography: return "containsProprietaryCryptography"
                    case .containsThirdPartyCryptography: return "containsThirdPartyCryptography"
                    case .documentName: return "documentName"
                    case .documentType: return "documentType"
                    case .documentUrl: return "documentUrl"
                    case .exempt: return "exempt"
                    case .platform: return "platform"
                    case .uploadedDate: return "uploadedDate"
                    case .usesEncryption: return "usesEncryption"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "appEncryptionDeclarationState": self = .appEncryptionDeclarationState
                    case "availableOnFrenchStore": self = .availableOnFrenchStore
                    case "builds": self = .builds
                    case "codeValue": self = .codeValue
                    case "containsProprietaryCryptography": self = .containsProprietaryCryptography
                    case "containsThirdPartyCryptography": self = .containsThirdPartyCryptography
                    case "documentName": self = .documentName
                    case "documentType": self = .documentType
                    case "documentUrl": self = .documentUrl
                    case "exempt": self = .exempt
                    case "platform": self = .platform
                    case "uploadedDate": self = .uploadedDate
                    case "usesEncryption": self = .usesEncryption
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppStoreVersions: Hashable, Codable, RawRepresentable {
                case ageRatingDeclaration
                case app
                case appClipDefaultExperience
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .ageRatingDeclaration: return "ageRatingDeclaration"
                    case .app: return "app"
                    case .appClipDefaultExperience: return "appClipDefaultExperience"
                    case .appStoreReviewDetail: return "appStoreReviewDetail"
                    case .appStoreState: return "appStoreState"
                    case .appStoreVersionLocalizations: return "appStoreVersionLocalizations"
                    case .appStoreVersionPhasedRelease: return "appStoreVersionPhasedRelease"
                    case .appStoreVersionSubmission: return "appStoreVersionSubmission"
                    case .build: return "build"
                    case .copyright: return "copyright"
                    case .createdDate: return "createdDate"
                    case .downloadable: return "downloadable"
                    case .earliestReleaseDate: return "earliestReleaseDate"
                    case .idfaDeclaration: return "idfaDeclaration"
                    case .platform: return "platform"
                    case .releaseType: return "releaseType"
                    case .routingAppCoverage: return "routingAppCoverage"
                    case .usesIdfa: return "usesIdfa"
                    case .versionString: return "versionString"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "ageRatingDeclaration": self = .ageRatingDeclaration
                    case "app": self = .app
                    case "appClipDefaultExperience": self = .appClipDefaultExperience
                    case "appStoreReviewDetail": self = .appStoreReviewDetail
                    case "appStoreState": self = .appStoreState
                    case "appStoreVersionLocalizations": self = .appStoreVersionLocalizations
                    case "appStoreVersionPhasedRelease": self = .appStoreVersionPhasedRelease
                    case "appStoreVersionSubmission": self = .appStoreVersionSubmission
                    case "build": self = .build
                    case "copyright": self = .copyright
                    case "createdDate": self = .createdDate
                    case "downloadable": self = .downloadable
                    case "earliestReleaseDate": self = .earliestReleaseDate
                    case "idfaDeclaration": self = .idfaDeclaration
                    case "platform": self = .platform
                    case "releaseType": self = .releaseType
                    case "routingAppCoverage": self = .routingAppCoverage
                    case "usesIdfa": self = .usesIdfa
                    case "versionString": self = .versionString
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Apps: Hashable, Codable, RawRepresentable {
                case appClips
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleId
                case ciProduct
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appClips: return "appClips"
                    case .appInfos: return "appInfos"
                    case .appStoreVersions: return "appStoreVersions"
                    case .availableInNewTerritories: return "availableInNewTerritories"
                    case .availableTerritories: return "availableTerritories"
                    case .betaAppLocalizations: return "betaAppLocalizations"
                    case .betaAppReviewDetail: return "betaAppReviewDetail"
                    case .betaGroups: return "betaGroups"
                    case .betaLicenseAgreement: return "betaLicenseAgreement"
                    case .betaTesters: return "betaTesters"
                    case .builds: return "builds"
                    case .bundleId: return "bundleId"
                    case .ciProduct: return "ciProduct"
                    case .contentRightsDeclaration: return "contentRightsDeclaration"
                    case .endUserLicenseAgreement: return "endUserLicenseAgreement"
                    case .gameCenterEnabledVersions: return "gameCenterEnabledVersions"
                    case .inAppPurchases: return "inAppPurchases"
                    case .isOrEverWasMadeForKids: return "isOrEverWasMadeForKids"
                    case .name: return "name"
                    case .perfPowerMetrics: return "perfPowerMetrics"
                    case .preOrder: return "preOrder"
                    case .preReleaseVersions: return "preReleaseVersions"
                    case .prices: return "prices"
                    case .primaryLocale: return "primaryLocale"
                    case .sku: return "sku"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "appClips": self = .appClips
                    case "appInfos": self = .appInfos
                    case "appStoreVersions": self = .appStoreVersions
                    case "availableInNewTerritories": self = .availableInNewTerritories
                    case "availableTerritories": self = .availableTerritories
                    case "betaAppLocalizations": self = .betaAppLocalizations
                    case "betaAppReviewDetail": self = .betaAppReviewDetail
                    case "betaGroups": self = .betaGroups
                    case "betaLicenseAgreement": self = .betaLicenseAgreement
                    case "betaTesters": self = .betaTesters
                    case "builds": self = .builds
                    case "bundleId": self = .bundleId
                    case "ciProduct": self = .ciProduct
                    case "contentRightsDeclaration": self = .contentRightsDeclaration
                    case "endUserLicenseAgreement": self = .endUserLicenseAgreement
                    case "gameCenterEnabledVersions": self = .gameCenterEnabledVersions
                    case "inAppPurchases": self = .inAppPurchases
                    case "isOrEverWasMadeForKids": self = .isOrEverWasMadeForKids
                    case "name": self = .name
                    case "perfPowerMetrics": self = .perfPowerMetrics
                    case "preOrder": self = .preOrder
                    case "preReleaseVersions": self = .preReleaseVersions
                    case "prices": self = .prices
                    case "primaryLocale": self = .primaryLocale
                    case "sku": self = .sku
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum BetaAppReviewSubmissions: Hashable, Codable, RawRepresentable {
                case betaReviewState
                case build
                case submittedDate
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .betaReviewState: return "betaReviewState"
                    case .build: return "build"
                    case .submittedDate: return "submittedDate"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "betaReviewState": self = .betaReviewState
                    case "build": self = .build
                    case "submittedDate": self = .submittedDate
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum BetaBuildLocalizations: Hashable, Codable, RawRepresentable {
                case build
                case locale
                case whatsNew
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .build: return "build"
                    case .locale: return "locale"
                    case .whatsNew: return "whatsNew"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "build": self = .build
                    case "locale": self = .locale
                    case "whatsNew": self = .whatsNew
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum BetaTesters: Hashable, Codable, RawRepresentable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .apps: return "apps"
                    case .betaGroups: return "betaGroups"
                    case .builds: return "builds"
                    case .email: return "email"
                    case .firstName: return "firstName"
                    case .inviteType: return "inviteType"
                    case .lastName: return "lastName"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "apps": self = .apps
                    case "betaGroups": self = .betaGroups
                    case "builds": self = .builds
                    case "email": self = .email
                    case "firstName": self = .firstName
                    case "inviteType": self = .inviteType
                    case "lastName": self = .lastName
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum BuildBetaDetails: Hashable, Codable, RawRepresentable {
                case autoNotifyEnabled
                case build
                case externalBuildState
                case internalBuildState
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .autoNotifyEnabled: return "autoNotifyEnabled"
                    case .build: return "build"
                    case .externalBuildState: return "externalBuildState"
                    case .internalBuildState: return "internalBuildState"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "autoNotifyEnabled": self = .autoNotifyEnabled
                    case "build": self = .build
                    case "externalBuildState": self = .externalBuildState
                    case "internalBuildState": self = .internalBuildState
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum BuildIcons: Hashable, Codable, RawRepresentable {
                case iconAsset
                case iconType
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .iconAsset: return "iconAsset"
                    case .iconType: return "iconType"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "iconAsset": self = .iconAsset
                    case "iconType": self = .iconType
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Builds: Hashable, Codable, RawRepresentable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildAudienceType
                case buildBetaDetail
                case buildBundles
                case computedMinMacOsVersion
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case lsMinimumSystemVersion
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .appEncryptionDeclaration: return "appEncryptionDeclaration"
                    case .appStoreVersion: return "appStoreVersion"
                    case .betaAppReviewSubmission: return "betaAppReviewSubmission"
                    case .betaBuildLocalizations: return "betaBuildLocalizations"
                    case .betaGroups: return "betaGroups"
                    case .buildAudienceType: return "buildAudienceType"
                    case .buildBetaDetail: return "buildBetaDetail"
                    case .buildBundles: return "buildBundles"
                    case .computedMinMacOsVersion: return "computedMinMacOsVersion"
                    case .diagnosticSignatures: return "diagnosticSignatures"
                    case .expirationDate: return "expirationDate"
                    case .expired: return "expired"
                    case .iconAssetToken: return "iconAssetToken"
                    case .icons: return "icons"
                    case .individualTesters: return "individualTesters"
                    case .lsMinimumSystemVersion: return "lsMinimumSystemVersion"
                    case .minOsVersion: return "minOsVersion"
                    case .perfPowerMetrics: return "perfPowerMetrics"
                    case .preReleaseVersion: return "preReleaseVersion"
                    case .processingState: return "processingState"
                    case .uploadedDate: return "uploadedDate"
                    case .usesNonExemptEncryption: return "usesNonExemptEncryption"
                    case .version: return "version"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "appEncryptionDeclaration": self = .appEncryptionDeclaration
                    case "appStoreVersion": self = .appStoreVersion
                    case "betaAppReviewSubmission": self = .betaAppReviewSubmission
                    case "betaBuildLocalizations": self = .betaBuildLocalizations
                    case "betaGroups": self = .betaGroups
                    case "buildAudienceType": self = .buildAudienceType
                    case "buildBetaDetail": self = .buildBetaDetail
                    case "buildBundles": self = .buildBundles
                    case "computedMinMacOsVersion": self = .computedMinMacOsVersion
                    case "diagnosticSignatures": self = .diagnosticSignatures
                    case "expirationDate": self = .expirationDate
                    case "expired": self = .expired
                    case "iconAssetToken": self = .iconAssetToken
                    case "icons": self = .icons
                    case "individualTesters": self = .individualTesters
                    case "lsMinimumSystemVersion": self = .lsMinimumSystemVersion
                    case "minOsVersion": self = .minOsVersion
                    case "perfPowerMetrics": self = .perfPowerMetrics
                    case "preReleaseVersion": self = .preReleaseVersion
                    case "processingState": self = .processingState
                    case "uploadedDate": self = .uploadedDate
                    case "usesNonExemptEncryption": self = .usesNonExemptEncryption
                    case "version": self = .version
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum DiagnosticSignatures: Hashable, Codable, RawRepresentable {
                case diagnosticType
                case logs
                case signature
                case weight
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .diagnosticType: return "diagnosticType"
                    case .logs: return "logs"
                    case .signature: return "signature"
                    case .weight: return "weight"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "diagnosticType": self = .diagnosticType
                    case "logs": self = .logs
                    case "signature": self = .signature
                    case "weight": self = .weight
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum PerfPowerMetrics: Hashable, Codable, RawRepresentable {
                case deviceType
                case metricType
                case platform
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .deviceType: return "deviceType"
                    case .metricType: return "metricType"
                    case .platform: return "platform"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "deviceType": self = .deviceType
                    case "metricType": self = .metricType
                    case "platform": self = .platform
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum PreReleaseVersions: Hashable, Codable, RawRepresentable {
                case app
                case builds
                case platform
                case version
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .builds: return "builds"
                    case .platform: return "platform"
                    case .version: return "version"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "builds": self = .builds
                    case "platform": self = .platform
                    case "version": self = .version
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type appEncryptionDeclarations
                public static var appEncryptionDeclarations: Relation<[AppEncryptionDeclarations]?> {
                    .init(key: "fields[appEncryptionDeclarations]")
                }

                /// the fields to include for returned resources of type appStoreVersions
                public static var appStoreVersions: Relation<[AppStoreVersions]?> {
                    .init(key: "fields[appStoreVersions]")
                }

                /// the fields to include for returned resources of type apps
                public static var apps: Relation<[Apps]?> {
                    .init(key: "fields[apps]")
                }

                /// the fields to include for returned resources of type betaAppReviewSubmissions
                public static var betaAppReviewSubmissions: Relation<[BetaAppReviewSubmissions]?> {
                    .init(key: "fields[betaAppReviewSubmissions]")
                }

                /// the fields to include for returned resources of type betaBuildLocalizations
                public static var betaBuildLocalizations: Relation<[BetaBuildLocalizations]?> {
                    .init(key: "fields[betaBuildLocalizations]")
                }

                /// the fields to include for returned resources of type betaTesters
                public static var betaTesters: Relation<[BetaTesters]?> {
                    .init(key: "fields[betaTesters]")
                }

                /// the fields to include for returned resources of type buildBetaDetails
                public static var buildBetaDetails: Relation<[BuildBetaDetails]?> {
                    .init(key: "fields[buildBetaDetails]")
                }

                /// the fields to include for returned resources of type buildIcons
                public static var buildIcons: Relation<[BuildIcons]?> {
                    .init(key: "fields[buildIcons]")
                }

                /// the fields to include for returned resources of type builds
                public static var builds: Relation<[Builds]?> {
                    .init(key: "fields[builds]")
                }

                /// the fields to include for returned resources of type diagnosticSignatures
                public static var diagnosticSignatures: Relation<[DiagnosticSignatures]?> {
                    .init(key: "fields[diagnosticSignatures]")
                }

                /// the fields to include for returned resources of type perfPowerMetrics
                public static var perfPowerMetrics: Relation<[PerfPowerMetrics]?> {
                    .init(key: "fields[perfPowerMetrics]")
                }

                /// the fields to include for returned resources of type preReleaseVersions
                public static var preReleaseVersions: Relation<[PreReleaseVersions]?> {
                    .init(key: "fields[preReleaseVersions]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum BetaAppReviewSubmissionBetaReviewState: Hashable, Codable, RawRepresentable {
                case approved
                case inReview
                case rejected
                case waitingForReview
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .approved: return "APPROVED"
                    case .inReview: return "IN_REVIEW"
                    case .rejected: return "REJECTED"
                    case .waitingForReview: return "WAITING_FOR_REVIEW"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "APPROVED": self = .approved
                    case "IN_REVIEW": self = .inReview
                    case "REJECTED": self = .rejected
                    case "WAITING_FOR_REVIEW": self = .waitingForReview
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum BuildAudienceType: Hashable, Codable, RawRepresentable {
                case appStoreEligible
                case internalOnly
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appStoreEligible: return "APP_STORE_ELIGIBLE"
                    case .internalOnly: return "INTERNAL_ONLY"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "APP_STORE_ELIGIBLE": self = .appStoreEligible
                    case "INTERNAL_ONLY": self = .internalOnly
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum PreReleaseVersionPlatform: Hashable, Codable, RawRepresentable {
                case iOS
                case macOS
                case tvOS
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .iOS: return "IOS"
                    case .macOS: return "MAC_OS"
                    case .tvOS: return "TV_OS"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "IOS": self = .iOS
                    case "MAC_OS": self = .macOS
                    case "TV_OS": self = .tvOS
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum ProcessingState: Hashable, Codable, RawRepresentable {
                case failed
                case invalid
                case processing
                case valid
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .failed: return "FAILED"
                    case .invalid: return "INVALID"
                    case .processing: return "PROCESSING"
                    case .valid: return "VALID"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "FAILED": self = .failed
                    case "INVALID": self = .invalid
                    case "PROCESSING": self = .processing
                    case "VALID": self = .valid
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// filter by id(s) of related 'appStoreVersion'
                public static var appStoreVersion: Relation<[String]?> {
                    .init(key: "filter[appStoreVersion]")
                }

                /// filter by id(s) of related 'app'
                public static var app: Relation<[String]?> {
                    .init(key: "filter[app]")
                }

                /// filter by attribute 'betaAppReviewSubmission.betaReviewState'
                public static var betaAppReviewSubmissionBetaReviewState: Relation<[BetaAppReviewSubmissionBetaReviewState]?> {
                    .init(key: "filter[betaAppReviewSubmission.betaReviewState]")
                }

                /// filter by id(s) of related 'betaGroups'
                public static var betaGroups: Relation<[String]?> {
                    .init(key: "filter[betaGroups]")
                }

                /// filter by attribute 'buildAudienceType'
                public static var buildAudienceType: Relation<[BuildAudienceType]?> {
                    .init(key: "filter[buildAudienceType]")
                }

                /// filter by attribute 'expired'
                public static var expired: Relation<[String]?> {
                    .init(key: "filter[expired]")
                }

                /// filter by id(s)
                public static var id: Relation<[String]?> {
                    .init(key: "filter[id]")
                }

                /// filter by attribute 'preReleaseVersion.platform'
                public static var preReleaseVersionPlatform: Relation<[PreReleaseVersionPlatform]?> {
                    .init(key: "filter[preReleaseVersion.platform]")
                }

                /// filter by attribute 'preReleaseVersion.version'
                public static var preReleaseVersionVersion: Relation<[String]?> {
                    .init(key: "filter[preReleaseVersion.version]")
                }

                /// filter by id(s) of related 'preReleaseVersion'
                public static var preReleaseVersion: Relation<[String]?> {
                    .init(key: "filter[preReleaseVersion]")
                }

                /// filter by attribute 'processingState'
                public static var processingState: Relation<[ProcessingState]?> {
                    .init(key: "filter[processingState]")
                }

                /// filter by attribute 'usesNonExemptEncryption'
                public static var usesNonExemptEncryption: Relation<[String]?> {
                    .init(key: "filter[usesNonExemptEncryption]")
                }

                /// filter by attribute 'version'
                public static var version: Relation<[String]?> {
                    .init(key: "filter[version]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case buildBetaDetail
            case buildBundles
            case icons
            case individualTesters
            case preReleaseVersion
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .app: return "app"
                case .appEncryptionDeclaration: return "appEncryptionDeclaration"
                case .appStoreVersion: return "appStoreVersion"
                case .betaAppReviewSubmission: return "betaAppReviewSubmission"
                case .betaBuildLocalizations: return "betaBuildLocalizations"
                case .buildBetaDetail: return "buildBetaDetail"
                case .buildBundles: return "buildBundles"
                case .icons: return "icons"
                case .individualTesters: return "individualTesters"
                case .preReleaseVersion: return "preReleaseVersion"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "app": self = .app
                case "appEncryptionDeclaration": self = .appEncryptionDeclaration
                case "appStoreVersion": self = .appStoreVersion
                case "betaAppReviewSubmission": self = .betaAppReviewSubmission
                case "betaBuildLocalizations": self = .betaBuildLocalizations
                case "buildBetaDetail": self = .buildBetaDetail
                case "buildBundles": self = .buildBundles
                case "icons": self = .icons
                case "individualTesters": self = .individualTesters
                case "preReleaseVersion": self = .preReleaseVersion
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related betaBuildLocalizations returned (when they are included)
                public static var betaBuildLocalizations: Relation<Int?> {
                    .init(key: "limit[betaBuildLocalizations]")
                }

                /// maximum number of related buildBundles returned (when they are included)
                public static var buildBundles: Relation<Int?> {
                    .init(key: "limit[buildBundles]")
                }

                /// maximum number of related icons returned (when they are included)
                public static var icons: Relation<Int?> {
                    .init(key: "limit[icons]")
                }

                /// maximum number of related individualTesters returned (when they are included)
                public static var individualTesters: Relation<Int?> {
                    .init(key: "limit[individualTesters]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Sort: Hashable, Codable, RawRepresentable {
            case preReleaseVersion
            case preReleaseVersionDesc
            case uploadedDate
            case uploadedDateDesc
            case version
            case versionDesc
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .preReleaseVersion: return "preReleaseVersion"
                case .preReleaseVersionDesc: return "-preReleaseVersion"
                case .uploadedDate: return "uploadedDate"
                case .uploadedDateDesc: return "-uploadedDate"
                case .version: return "version"
                case .versionDesc: return "-version"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "preReleaseVersion": self = .preReleaseVersion
                case "-preReleaseVersion": self = .preReleaseVersionDesc
                case "uploadedDate": self = .uploadedDate
                case "-uploadedDate": self = .uploadedDateDesc
                case "version": self = .version
                case "-version": self = .versionDesc
                default: self = .unknown(rawValue)
                }
            }
        }
    }
}

// swiftlint:enable all
