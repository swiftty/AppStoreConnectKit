// autogenerated

// swiftlint:disable all
import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension V1.BundleIds {
    public struct GET: Endpoint {
        public typealias Response = BundleIdsResponse

        public var path: String {
            "/v1/bundleIds"
        }

        public var parameters: Parameters = Parameters()

        public init() {

        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[apps]",
                             value: parameters.fields[.apps]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[bundleIdCapabilities]",
                             value: parameters.fields[.bundleIdCapabilities]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[bundleIds]",
                             value: parameters.fields[.bundleIds]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[profiles]",
                             value: parameters.fields[.profiles]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[id]",
                             value: parameters.filter[.id]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[identifier]",
                             value: parameters.filter[.identifier]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[name]",
                             value: parameters.filter[.name]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[platform]",
                             value: parameters.filter[.platform]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[seedId]",
                             value: parameters.filter[.seedId]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[bundleIdCapabilities]",
                             value: parameters.limit[.bundleIdCapabilities].map { "\($0)" }),
                URLQueryItem(name: "limit[profiles]",
                             value: parameters.limit[.profiles].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" }),
                URLQueryItem(name: "sort",
                             value: parameters.sort?.map { "\($0)" }.joined(separator: ","))
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of BundleIds as `BundleIdsResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(BundleIdsResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.BundleIds.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        /// comma-separated list of sort expressions; resources will be sorted as specified
        public var sort: [Sort]?

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum Apps: Hashable, Codable, RawRepresentable {
                case appClips
                case appCustomProductPages
                case appEvents
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleId
                case ciProduct
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case reviewSubmissions
                case sku
                case subscriptionStatusUrl
                case subscriptionStatusUrlForSandbox
                case subscriptionStatusUrlVersion
                case subscriptionStatusUrlVersionForSandbox
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appClips: return "appClips"
                    case .appCustomProductPages: return "appCustomProductPages"
                    case .appEvents: return "appEvents"
                    case .appInfos: return "appInfos"
                    case .appStoreVersions: return "appStoreVersions"
                    case .availableInNewTerritories: return "availableInNewTerritories"
                    case .availableTerritories: return "availableTerritories"
                    case .betaAppLocalizations: return "betaAppLocalizations"
                    case .betaAppReviewDetail: return "betaAppReviewDetail"
                    case .betaGroups: return "betaGroups"
                    case .betaLicenseAgreement: return "betaLicenseAgreement"
                    case .betaTesters: return "betaTesters"
                    case .builds: return "builds"
                    case .bundleId: return "bundleId"
                    case .ciProduct: return "ciProduct"
                    case .contentRightsDeclaration: return "contentRightsDeclaration"
                    case .endUserLicenseAgreement: return "endUserLicenseAgreement"
                    case .gameCenterEnabledVersions: return "gameCenterEnabledVersions"
                    case .inAppPurchases: return "inAppPurchases"
                    case .isOrEverWasMadeForKids: return "isOrEverWasMadeForKids"
                    case .name: return "name"
                    case .perfPowerMetrics: return "perfPowerMetrics"
                    case .preOrder: return "preOrder"
                    case .preReleaseVersions: return "preReleaseVersions"
                    case .prices: return "prices"
                    case .primaryLocale: return "primaryLocale"
                    case .reviewSubmissions: return "reviewSubmissions"
                    case .sku: return "sku"
                    case .subscriptionStatusUrl: return "subscriptionStatusUrl"
                    case .subscriptionStatusUrlForSandbox: return "subscriptionStatusUrlForSandbox"
                    case .subscriptionStatusUrlVersion: return "subscriptionStatusUrlVersion"
                    case .subscriptionStatusUrlVersionForSandbox: return "subscriptionStatusUrlVersionForSandbox"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "appClips": self = .appClips
                    case "appCustomProductPages": self = .appCustomProductPages
                    case "appEvents": self = .appEvents
                    case "appInfos": self = .appInfos
                    case "appStoreVersions": self = .appStoreVersions
                    case "availableInNewTerritories": self = .availableInNewTerritories
                    case "availableTerritories": self = .availableTerritories
                    case "betaAppLocalizations": self = .betaAppLocalizations
                    case "betaAppReviewDetail": self = .betaAppReviewDetail
                    case "betaGroups": self = .betaGroups
                    case "betaLicenseAgreement": self = .betaLicenseAgreement
                    case "betaTesters": self = .betaTesters
                    case "builds": self = .builds
                    case "bundleId": self = .bundleId
                    case "ciProduct": self = .ciProduct
                    case "contentRightsDeclaration": self = .contentRightsDeclaration
                    case "endUserLicenseAgreement": self = .endUserLicenseAgreement
                    case "gameCenterEnabledVersions": self = .gameCenterEnabledVersions
                    case "inAppPurchases": self = .inAppPurchases
                    case "isOrEverWasMadeForKids": self = .isOrEverWasMadeForKids
                    case "name": self = .name
                    case "perfPowerMetrics": self = .perfPowerMetrics
                    case "preOrder": self = .preOrder
                    case "preReleaseVersions": self = .preReleaseVersions
                    case "prices": self = .prices
                    case "primaryLocale": self = .primaryLocale
                    case "reviewSubmissions": self = .reviewSubmissions
                    case "sku": self = .sku
                    case "subscriptionStatusUrl": self = .subscriptionStatusUrl
                    case "subscriptionStatusUrlForSandbox": self = .subscriptionStatusUrlForSandbox
                    case "subscriptionStatusUrlVersion": self = .subscriptionStatusUrlVersion
                    case "subscriptionStatusUrlVersionForSandbox": self = .subscriptionStatusUrlVersionForSandbox
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum BundleIdCapabilities: Hashable, Codable, RawRepresentable {
                case bundleId
                case capabilityType
                case settings
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .bundleId: return "bundleId"
                    case .capabilityType: return "capabilityType"
                    case .settings: return "settings"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "bundleId": self = .bundleId
                    case "capabilityType": self = .capabilityType
                    case "settings": self = .settings
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum BundleIds: Hashable, Codable, RawRepresentable {
                case app
                case bundleIdCapabilities
                case identifier
                case name
                case platform
                case profiles
                case seedId
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .bundleIdCapabilities: return "bundleIdCapabilities"
                    case .identifier: return "identifier"
                    case .name: return "name"
                    case .platform: return "platform"
                    case .profiles: return "profiles"
                    case .seedId: return "seedId"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "bundleIdCapabilities": self = .bundleIdCapabilities
                    case "identifier": self = .identifier
                    case "name": self = .name
                    case "platform": self = .platform
                    case "profiles": self = .profiles
                    case "seedId": self = .seedId
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Profiles: Hashable, Codable, RawRepresentable {
                case bundleId
                case certificates
                case createdDate
                case devices
                case expirationDate
                case name
                case platform
                case profileContent
                case profileState
                case profileType
                case uuid
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .bundleId: return "bundleId"
                    case .certificates: return "certificates"
                    case .createdDate: return "createdDate"
                    case .devices: return "devices"
                    case .expirationDate: return "expirationDate"
                    case .name: return "name"
                    case .platform: return "platform"
                    case .profileContent: return "profileContent"
                    case .profileState: return "profileState"
                    case .profileType: return "profileType"
                    case .uuid: return "uuid"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "bundleId": self = .bundleId
                    case "certificates": self = .certificates
                    case "createdDate": self = .createdDate
                    case "devices": self = .devices
                    case "expirationDate": self = .expirationDate
                    case "name": self = .name
                    case "platform": self = .platform
                    case "profileContent": self = .profileContent
                    case "profileState": self = .profileState
                    case "profileType": self = .profileType
                    case "uuid": self = .uuid
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type apps
                public static var apps: Relation<[Apps]?> {
                    .init(key: "fields[apps]")
                }

                /// the fields to include for returned resources of type bundleIdCapabilities
                public static var bundleIdCapabilities: Relation<[BundleIdCapabilities]?> {
                    .init(key: "fields[bundleIdCapabilities]")
                }

                /// the fields to include for returned resources of type bundleIds
                public static var bundleIds: Relation<[BundleIds]?> {
                    .init(key: "fields[bundleIds]")
                }

                /// the fields to include for returned resources of type profiles
                public static var profiles: Relation<[Profiles]?> {
                    .init(key: "fields[profiles]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum Platform: Hashable, Codable, RawRepresentable {
                case iOS
                case macOS
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .iOS: return "IOS"
                    case .macOS: return "MAC_OS"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "IOS": self = .iOS
                    case "MAC_OS": self = .macOS
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// filter by id(s)
                public static var id: Relation<[String]?> {
                    .init(key: "filter[id]")
                }

                /// filter by attribute 'identifier'
                public static var identifier: Relation<[String]?> {
                    .init(key: "filter[identifier]")
                }

                /// filter by attribute 'name'
                public static var name: Relation<[String]?> {
                    .init(key: "filter[name]")
                }

                /// filter by attribute 'platform'
                public static var platform: Relation<[Platform]?> {
                    .init(key: "filter[platform]")
                }

                /// filter by attribute 'seedId'
                public static var seedId: Relation<[String]?> {
                    .init(key: "filter[seedId]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case app
            case bundleIdCapabilities
            case profiles
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .app: return "app"
                case .bundleIdCapabilities: return "bundleIdCapabilities"
                case .profiles: return "profiles"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "app": self = .app
                case "bundleIdCapabilities": self = .bundleIdCapabilities
                case "profiles": self = .profiles
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related bundleIdCapabilities returned (when they are included)
                public static var bundleIdCapabilities: Relation<Int?> {
                    .init(key: "limit[bundleIdCapabilities]")
                }

                /// maximum number of related profiles returned (when they are included)
                public static var profiles: Relation<Int?> {
                    .init(key: "limit[profiles]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Sort: Hashable, Codable, RawRepresentable {
            case id
            case idDesc
            case identifier
            case identifierDesc
            case name
            case nameDesc
            case platform
            case platformDesc
            case seedId
            case seedIdDesc
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .id: return "id"
                case .idDesc: return "-id"
                case .identifier: return "identifier"
                case .identifierDesc: return "-identifier"
                case .name: return "name"
                case .nameDesc: return "-name"
                case .platform: return "platform"
                case .platformDesc: return "-platform"
                case .seedId: return "seedId"
                case .seedIdDesc: return "-seedId"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "id": self = .id
                case "-id": self = .idDesc
                case "identifier": self = .identifier
                case "-identifier": self = .identifierDesc
                case "name": self = .name
                case "-name": self = .nameDesc
                case "platform": self = .platform
                case "-platform": self = .platformDesc
                case "seedId": self = .seedId
                case "-seedId": self = .seedIdDesc
                default: self = .unknown(rawValue)
                }
            }
        }
    }
}

// swiftlint:enable all
