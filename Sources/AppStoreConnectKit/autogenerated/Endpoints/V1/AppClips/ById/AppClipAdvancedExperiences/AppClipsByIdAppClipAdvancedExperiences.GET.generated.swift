// autogenerated

// swiftlint:disable all
import Foundation

extension V1.AppClips.ById.AppClipAdvancedExperiences {
    public struct GET: Endpoint {
        public typealias Response = AppClipAdvancedExperiencesResponse

        public var path: String {
            "/v1/appClips/\(id)/appClipAdvancedExperiences"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[appClipAdvancedExperienceLocalizations]",
                             value: parameters.fields[.appClipAdvancedExperienceLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appClipAdvancedExperiences]",
                             value: parameters.fields[.appClipAdvancedExperiences]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[action]",
                             value: parameters.filter[.action]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[placeStatus]",
                             value: parameters.filter[.placeStatus]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[status]",
                             value: parameters.filter[.status]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[localizations]",
                             value: parameters.limit[.localizations].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" })
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of related resources as `AppClipAdvancedExperiencesResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(AppClipAdvancedExperiencesResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.AppClips.ById.AppClipAdvancedExperiences.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppClipAdvancedExperienceLocalizations: Hashable, Codable, RawRepresentable {
                case language
                case subtitle
                case title
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .language: return "language"
                    case .subtitle: return "subtitle"
                    case .title: return "title"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "language": self = .language
                    case "subtitle": self = .subtitle
                    case "title": self = .title
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppClipAdvancedExperiences: Hashable, Codable, RawRepresentable {
                case action
                case appClip
                case businessCategory
                case defaultLanguage
                case headerImage
                case isPoweredBy
                case link
                case localizations
                case place
                case placeStatus
                case removed
                case status
                case version
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .action: return "action"
                    case .appClip: return "appClip"
                    case .businessCategory: return "businessCategory"
                    case .defaultLanguage: return "defaultLanguage"
                    case .headerImage: return "headerImage"
                    case .isPoweredBy: return "isPoweredBy"
                    case .link: return "link"
                    case .localizations: return "localizations"
                    case .place: return "place"
                    case .placeStatus: return "placeStatus"
                    case .removed: return "removed"
                    case .status: return "status"
                    case .version: return "version"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "action": self = .action
                    case "appClip": self = .appClip
                    case "businessCategory": self = .businessCategory
                    case "defaultLanguage": self = .defaultLanguage
                    case "headerImage": self = .headerImage
                    case "isPoweredBy": self = .isPoweredBy
                    case "link": self = .link
                    case "localizations": self = .localizations
                    case "place": self = .place
                    case "placeStatus": self = .placeStatus
                    case "removed": self = .removed
                    case "status": self = .status
                    case "version": self = .version
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type appClipAdvancedExperienceLocalizations
                public static var appClipAdvancedExperienceLocalizations: Relation<[AppClipAdvancedExperienceLocalizations]?> {
                    .init(key: "fields[appClipAdvancedExperienceLocalizations]")
                }

                /// the fields to include for returned resources of type appClipAdvancedExperiences
                public static var appClipAdvancedExperiences: Relation<[AppClipAdvancedExperiences]?> {
                    .init(key: "fields[appClipAdvancedExperiences]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum Action: Hashable, Codable, RawRepresentable {
                case open
                case play
                case view
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .open: return "OPEN"
                    case .play: return "PLAY"
                    case .view: return "VIEW"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "OPEN": self = .open
                    case "PLAY": self = .play
                    case "VIEW": self = .view
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum PlaceStatus: Hashable, Codable, RawRepresentable {
                case matched
                case noMatch
                case pending
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .matched: return "MATCHED"
                    case .noMatch: return "NO_MATCH"
                    case .pending: return "PENDING"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "MATCHED": self = .matched
                    case "NO_MATCH": self = .noMatch
                    case "PENDING": self = .pending
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Status: Hashable, Codable, RawRepresentable {
                case appTransferInProgress
                case deactivated
                case received
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appTransferInProgress: return "APP_TRANSFER_IN_PROGRESS"
                    case .deactivated: return "DEACTIVATED"
                    case .received: return "RECEIVED"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "APP_TRANSFER_IN_PROGRESS": self = .appTransferInProgress
                    case "DEACTIVATED": self = .deactivated
                    case "RECEIVED": self = .received
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// filter by attribute 'action'
                public static var action: Relation<[Action]?> {
                    .init(key: "filter[action]")
                }

                /// filter by attribute 'placeStatus'
                public static var placeStatus: Relation<[PlaceStatus]?> {
                    .init(key: "filter[placeStatus]")
                }

                /// filter by attribute 'status'
                public static var status: Relation<[Status]?> {
                    .init(key: "filter[status]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case localizations
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .localizations: return "localizations"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "localizations": self = .localizations
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related localizations returned (when they are included)
                public static var localizations: Relation<Int?> {
                    .init(key: "limit[localizations]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }
    }
}

// swiftlint:enable all
