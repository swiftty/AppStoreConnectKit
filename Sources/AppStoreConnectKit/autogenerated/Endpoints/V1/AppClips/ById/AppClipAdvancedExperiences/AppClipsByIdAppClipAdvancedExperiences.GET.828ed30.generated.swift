// autogenerated

// swiftlint:disable all
import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension V1.AppClips.ById.AppClipAdvancedExperiences {
    public struct GET: Endpoint {
        public typealias Response = AppClipAdvancedExperiencesResponse

        public var path: String {
            "/v1/appClips/\(id)/appClipAdvancedExperiences"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[appClipAdvancedExperienceImages]",
                             value: parameters.fields[.appClipAdvancedExperienceImages]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appClipAdvancedExperienceLocalizations]",
                             value: parameters.fields[.appClipAdvancedExperienceLocalizations]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appClipAdvancedExperiences]",
                             value: parameters.fields[.appClipAdvancedExperiences]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[appClips]",
                             value: parameters.fields[.appClips]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[action]",
                             value: parameters.filter[.action]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[placeStatus]",
                             value: parameters.filter[.placeStatus]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[status]",
                             value: parameters.filter[.status]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[localizations]",
                             value: parameters.limit[.localizations].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" })
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of AppClipAdvancedExperiences as `AppClipAdvancedExperiencesResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(AppClipAdvancedExperiencesResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.AppClips.ById.AppClipAdvancedExperiences.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<Self, T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum AppClipAdvancedExperienceImages: Hashable, Codable, RawRepresentable {
                case assetDeliveryState
                case fileName
                case fileSize
                case imageAsset
                case sourceFileChecksum
                case uploadOperations
                case uploaded
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .assetDeliveryState: return "assetDeliveryState"
                    case .fileName: return "fileName"
                    case .fileSize: return "fileSize"
                    case .imageAsset: return "imageAsset"
                    case .sourceFileChecksum: return "sourceFileChecksum"
                    case .uploadOperations: return "uploadOperations"
                    case .uploaded: return "uploaded"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "assetDeliveryState": self = .assetDeliveryState
                    case "fileName": self = .fileName
                    case "fileSize": self = .fileSize
                    case "imageAsset": self = .imageAsset
                    case "sourceFileChecksum": self = .sourceFileChecksum
                    case "uploadOperations": self = .uploadOperations
                    case "uploaded": self = .uploaded
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppClipAdvancedExperienceLocalizations: Hashable, Codable, RawRepresentable {
                case language
                case subtitle
                case title
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .language: return "language"
                    case .subtitle: return "subtitle"
                    case .title: return "title"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "language": self = .language
                    case "subtitle": self = .subtitle
                    case "title": self = .title
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppClipAdvancedExperiences: Hashable, Codable, RawRepresentable {
                case action
                case appClip
                case businessCategory
                case defaultLanguage
                case headerImage
                case isPoweredBy
                case link
                case localizations
                case place
                case placeStatus
                case removed
                case status
                case version
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .action: return "action"
                    case .appClip: return "appClip"
                    case .businessCategory: return "businessCategory"
                    case .defaultLanguage: return "defaultLanguage"
                    case .headerImage: return "headerImage"
                    case .isPoweredBy: return "isPoweredBy"
                    case .link: return "link"
                    case .localizations: return "localizations"
                    case .place: return "place"
                    case .placeStatus: return "placeStatus"
                    case .removed: return "removed"
                    case .status: return "status"
                    case .version: return "version"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "action": self = .action
                    case "appClip": self = .appClip
                    case "businessCategory": self = .businessCategory
                    case "defaultLanguage": self = .defaultLanguage
                    case "headerImage": self = .headerImage
                    case "isPoweredBy": self = .isPoweredBy
                    case "link": self = .link
                    case "localizations": self = .localizations
                    case "place": self = .place
                    case "placeStatus": self = .placeStatus
                    case "removed": self = .removed
                    case "status": self = .status
                    case "version": self = .version
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum AppClips: Hashable, Codable, RawRepresentable {
                case app
                case appClipAdvancedExperiences
                case appClipDefaultExperiences
                case bundleId
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .appClipAdvancedExperiences: return "appClipAdvancedExperiences"
                    case .appClipDefaultExperiences: return "appClipDefaultExperiences"
                    case .bundleId: return "bundleId"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "appClipAdvancedExperiences": self = .appClipAdvancedExperiences
                    case "appClipDefaultExperiences": self = .appClipDefaultExperiences
                    case "bundleId": self = .bundleId
                    default: self = .unknown(rawValue)
                    }
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<Self, T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum Action: Hashable, Codable, RawRepresentable {
                case open
                case play
                case view
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .open: return "OPEN"
                    case .play: return "PLAY"
                    case .view: return "VIEW"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "OPEN": self = .open
                    case "PLAY": self = .play
                    case "VIEW": self = .view
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum PlaceStatus: Hashable, Codable, RawRepresentable {
                case matched
                case noMatch
                case pending
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .matched: return "MATCHED"
                    case .noMatch: return "NO_MATCH"
                    case .pending: return "PENDING"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "MATCHED": self = .matched
                    case "NO_MATCH": self = .noMatch
                    case "PENDING": self = .pending
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public enum Status: Hashable, Codable, RawRepresentable {
                case appTransferInProgress
                case deactivated
                case received
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .appTransferInProgress: return "APP_TRANSFER_IN_PROGRESS"
                    case .deactivated: return "DEACTIVATED"
                    case .received: return "RECEIVED"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "APP_TRANSFER_IN_PROGRESS": self = .appTransferInProgress
                    case "DEACTIVATED": self = .deactivated
                    case "RECEIVED": self = .received
                    default: self = .unknown(rawValue)
                    }
                }
            }
        }

        public enum Include: Hashable, Codable, RawRepresentable {
            case appClip
            case headerImage
            case localizations
            case unknown(String)

            public var rawValue: String {
                switch self {
                case .appClip: return "appClip"
                case .headerImage: return "headerImage"
                case .localizations: return "localizations"
                case .unknown(let rawValue): return rawValue
                }
            }

            public init(rawValue: String) {
                switch rawValue {
                case "appClip": self = .appClip
                case "headerImage": self = .headerImage
                case "localizations": self = .localizations
                default: self = .unknown(rawValue)
                }
            }
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Self, Int?>(key: "limit")] }
                set { self[Relation<Self, Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<Self, T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]
        }
    }
}

extension Relation<V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Fields, [V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Fields.AppClipAdvancedExperienceImages]?> {
    /// the fields to include for returned resources of type appClipAdvancedExperienceImages
    public static var appClipAdvancedExperienceImages: Relation {
        .init(key: "fields[appClipAdvancedExperienceImages]")
    }
}

extension Relation<V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Fields, [V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Fields.AppClipAdvancedExperienceLocalizations]?> {
    /// the fields to include for returned resources of type appClipAdvancedExperienceLocalizations
    public static var appClipAdvancedExperienceLocalizations: Relation {
        .init(key: "fields[appClipAdvancedExperienceLocalizations]")
    }
}

extension Relation<V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Fields, [V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Fields.AppClipAdvancedExperiences]?> {
    /// the fields to include for returned resources of type appClipAdvancedExperiences
    public static var appClipAdvancedExperiences: Relation {
        .init(key: "fields[appClipAdvancedExperiences]")
    }
}

extension Relation<V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Fields, [V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Fields.AppClips]?> {
    /// the fields to include for returned resources of type appClips
    public static var appClips: Relation {
        .init(key: "fields[appClips]")
    }
}

extension Relation<V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Filter, [V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Filter.Action]?> {
    /// filter by attribute 'action'
    public static var action: Relation {
        .init(key: "filter[action]")
    }
}

extension Relation<V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Filter, [V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Filter.PlaceStatus]?> {
    /// filter by attribute 'placeStatus'
    public static var placeStatus: Relation {
        .init(key: "filter[placeStatus]")
    }
}

extension Relation<V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Filter, [V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Filter.Status]?> {
    /// filter by attribute 'status'
    public static var status: Relation {
        .init(key: "filter[status]")
    }
}

extension Relation<V1.AppClips.ById.AppClipAdvancedExperiences.GET.Parameters.Limit, Int?> {
    /// maximum number of related localizations returned (when they are included)
    public static var localizations: Relation {
        .init(key: "limit[localizations]")
    }
}

// swiftlint:enable all
