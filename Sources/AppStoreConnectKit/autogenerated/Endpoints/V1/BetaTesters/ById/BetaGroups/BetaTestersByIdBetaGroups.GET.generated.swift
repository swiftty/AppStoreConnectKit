// autogenerated

// swiftlint:disable all
import Foundation

extension V1.BetaTesters.ById.BetaGroups {
    public struct GET: Endpoint {
        public typealias Response = BetaGroupsResponse

        public var path: String {
            "/v1/betaTesters/\(id)/betaGroups"
        }

        /// the id of the requested resource
        public var id: String

        public var parameters: Parameters = Parameters()

        public init(id: String) {
            self.id = id
        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[betaGroups]",
                             value: parameters.fields[.betaGroups]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit",
                             value: parameters.limit.map { "\($0)" })
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of related resources as `BetaGroupsResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        /// - Throws: **404**, Not found error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(BetaGroupsResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 404:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.BetaTesters.ById.BetaGroups.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        /// maximum resources per page
        public var limit: Int?

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum BetaGroups: Hashable, Codable, RawRepresentable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case hasAccessToAllBuilds
                case iosBuildsAvailableForAppleSiliconMac
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkId
                case publicLinkLimit
                case publicLinkLimitEnabled
                case unknown(String)

                public var rawValue: String {
                    switch self {
                    case .app: return "app"
                    case .betaTesters: return "betaTesters"
                    case .builds: return "builds"
                    case .createdDate: return "createdDate"
                    case .feedbackEnabled: return "feedbackEnabled"
                    case .hasAccessToAllBuilds: return "hasAccessToAllBuilds"
                    case .iosBuildsAvailableForAppleSiliconMac: return "iosBuildsAvailableForAppleSiliconMac"
                    case .isInternalGroup: return "isInternalGroup"
                    case .name: return "name"
                    case .publicLink: return "publicLink"
                    case .publicLinkEnabled: return "publicLinkEnabled"
                    case .publicLinkId: return "publicLinkId"
                    case .publicLinkLimit: return "publicLinkLimit"
                    case .publicLinkLimitEnabled: return "publicLinkLimitEnabled"
                    case .unknown(let rawValue): return rawValue
                    }
                }

                public init(rawValue: String) {
                    switch rawValue {
                    case "app": self = .app
                    case "betaTesters": self = .betaTesters
                    case "builds": self = .builds
                    case "createdDate": self = .createdDate
                    case "feedbackEnabled": self = .feedbackEnabled
                    case "hasAccessToAllBuilds": self = .hasAccessToAllBuilds
                    case "iosBuildsAvailableForAppleSiliconMac": self = .iosBuildsAvailableForAppleSiliconMac
                    case "isInternalGroup": self = .isInternalGroup
                    case "name": self = .name
                    case "publicLink": self = .publicLink
                    case "publicLinkEnabled": self = .publicLinkEnabled
                    case "publicLinkId": self = .publicLinkId
                    case "publicLinkLimit": self = .publicLinkLimit
                    case "publicLinkLimitEnabled": self = .publicLinkLimitEnabled
                    default: self = .unknown(rawValue)
                    }
                }
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type betaGroups
                public static var betaGroups: Relation<[BetaGroups]?> {
                    .init(key: "fields[betaGroups]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }
    }
}

// swiftlint:enable all
