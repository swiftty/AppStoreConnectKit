// autogenerated

// swiftlint:disable all
import Foundation

extension V1.BetaTesters {
    public struct GET: Endpoint {
        public typealias Response = BetaTestersResponse

        public var path: String {
            "/v1/betaTesters"
        }

        public var parameters: Parameters = Parameters()

        public init() {

        }

        public func request(with baseURL: URL) throws -> URLRequest? {
            var components = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)
            components?.path = path

            components?.queryItems = [
                URLQueryItem(name: "fields[apps]",
                             value: parameters.fields[.apps]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaGroups]",
                             value: parameters.fields[.betaGroups]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[betaTesters]",
                             value: parameters.fields[.betaTesters]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "fields[builds]",
                             value: parameters.fields[.builds]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[apps]",
                             value: parameters.filter[.apps]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[betaGroups]",
                             value: parameters.filter[.betaGroups]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[builds]",
                             value: parameters.filter[.builds]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[email]",
                             value: parameters.filter[.email]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[firstName]",
                             value: parameters.filter[.firstName]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[id]",
                             value: parameters.filter[.id]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[inviteType]",
                             value: parameters.filter[.inviteType]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "filter[lastName]",
                             value: parameters.filter[.lastName]?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "include",
                             value: parameters.include?.map { "\($0)" }.joined(separator: ",")),
                URLQueryItem(name: "limit[apps]",
                             value: parameters.limit[.apps].map { "\($0)" }),
                URLQueryItem(name: "limit[betaGroups]",
                             value: parameters.limit[.betaGroups].map { "\($0)" }),
                URLQueryItem(name: "limit[builds]",
                             value: parameters.limit[.builds].map { "\($0)" }),
                URLQueryItem(name: "limit",
                             value: parameters.limit[].map { "\($0)" }),
                URLQueryItem(name: "sort",
                             value: parameters.sort?.map { "\($0)" }.joined(separator: ","))
            ].filter { $0.value != nil }
            if components?.queryItems?.isEmpty ?? false {
                components?.queryItems = nil
            }

            var urlRequest = components?.url.map { URLRequest(url: $0) }
            urlRequest?.httpMethod = "GET"
            return urlRequest
        }

        /// - Returns: **200**, List of BetaTesters as `BetaTestersResponse`
        /// - Throws: **400**, Parameter error(s) as `ErrorResponse`
        /// - Throws: **403**, Forbidden error as `ErrorResponse`
        public static func response(from data: Data, urlResponse: HTTPURLResponse) throws -> Response {
            var jsonDecoder: JSONDecoder {
                let decoder = JSONDecoder()
                return decoder
            }

            switch urlResponse.statusCode {
            case 200:
                return try jsonDecoder.decode(BetaTestersResponse.self, from: data)

            case 400:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            case 403:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)

            default:
                throw try jsonDecoder.decode(ErrorResponse.self, from: data)
            }
        }
    }
}

extension V1.BetaTesters.GET {
    public struct Parameters: Hashable {
        public var fields: Fields = Fields()

        public var filter: Filter = Filter()

        /// comma-separated list of relationships to include
        public var include: [Include]?

        /// maximum resources per page
        public var limit: Limit = Limit()

        /// comma-separated list of sort expressions; resources will be sorted as specified
        public var sort: [Sort]?

        public struct Fields: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum Apps: String, Hashable, Codable {
                case appClips
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleId
                case ciProduct
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum BetaGroups: String, Hashable, Codable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case hasAccessToAllBuilds
                case iosBuildsAvailableForAppleSiliconMac
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkId
                case publicLinkLimit
                case publicLinkLimitEnabled
            }

            public enum BetaTesters: String, Hashable, Codable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
            }

            public enum Builds: String, Hashable, Codable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildAudienceType
                case buildBetaDetail
                case buildBundles
                case computedMinMacOsVersion
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case lsMinimumSystemVersion
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public struct Relation<T>: Hashable {
                /// the fields to include for returned resources of type apps
                public static var apps: Relation<[Apps]?> {
                    .init(key: "fields[apps]")
                }

                /// the fields to include for returned resources of type betaGroups
                public static var betaGroups: Relation<[BetaGroups]?> {
                    .init(key: "fields[betaGroups]")
                }

                /// the fields to include for returned resources of type betaTesters
                public static var betaTesters: Relation<[BetaTesters]?> {
                    .init(key: "fields[betaTesters]")
                }

                /// the fields to include for returned resources of type builds
                public static var builds: Relation<[Builds]?> {
                    .init(key: "fields[builds]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public struct Filter: Hashable {
            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public enum InviteType: String, Hashable, Codable {
                case email = "EMAIL"
                case publicLink = "PUBLIC_LINK"
            }

            public struct Relation<T>: Hashable {
                /// filter by id(s) of related 'apps'
                public static var apps: Relation<[String]?> {
                    .init(key: "filter[apps]")
                }

                /// filter by id(s) of related 'betaGroups'
                public static var betaGroups: Relation<[String]?> {
                    .init(key: "filter[betaGroups]")
                }

                /// filter by id(s) of related 'builds'
                public static var builds: Relation<[String]?> {
                    .init(key: "filter[builds]")
                }

                /// filter by attribute 'email'
                public static var email: Relation<[String]?> {
                    .init(key: "filter[email]")
                }

                /// filter by attribute 'firstName'
                public static var firstName: Relation<[String]?> {
                    .init(key: "filter[firstName]")
                }

                /// filter by id(s)
                public static var id: Relation<[String]?> {
                    .init(key: "filter[id]")
                }

                /// filter by attribute 'inviteType'
                public static var inviteType: Relation<[InviteType]?> {
                    .init(key: "filter[inviteType]")
                }

                /// filter by attribute 'lastName'
                public static var lastName: Relation<[String]?> {
                    .init(key: "filter[lastName]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Include: String, Hashable, Codable {
            case apps
            case betaGroups
            case builds
        }

        public struct Limit: Hashable {
            public subscript () -> Int? {
                get { self[Relation<Int?>(key: "limit")] }
                set { self[Relation<Int?>(key: "limit")] = newValue }
            }

            public subscript <T: Hashable>(_ relation: Relation<T>) -> T {
                get { values[relation]?.base as! T }
                set { values[relation] = AnyHashable(newValue) }
            }

            private var values: [AnyHashable: AnyHashable] = [:]

            public struct Relation<T>: Hashable {
                /// maximum number of related apps returned (when they are included)
                public static var apps: Relation<Int?> {
                    .init(key: "limit[apps]")
                }

                /// maximum number of related betaGroups returned (when they are included)
                public static var betaGroups: Relation<Int?> {
                    .init(key: "limit[betaGroups]")
                }

                /// maximum number of related builds returned (when they are included)
                public static var builds: Relation<Int?> {
                    .init(key: "limit[builds]")
                }

                internal let key: String

                public func hash(into hasher: inout Hasher) {
                    hasher.combine(key)
                }
            }
        }

        public enum Sort: String, Hashable, Codable {
            case emailDesc = "-email"
            case firstNameDesc = "-firstName"
            case inviteTypeDesc = "-inviteType"
            case lastNameDesc = "-lastName"
            case email
            case firstName
            case inviteType
            case lastName
        }
    }
}

// swiftlint:enable all
