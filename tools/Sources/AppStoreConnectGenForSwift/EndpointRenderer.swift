import Foundation
import CryptoKit
import AppStoreConnectGenKit

struct EndpointRenderer: Renderer {
    enum Method: String {
        case GET, POST, PATCH, DELETE
    }
    var endpoint: OpenAPIEndpoint
    var context: SwiftCodeBuilder.Context
    var filePath: String

    let path: String
    let pathComponents: [String]
    let name: String
    let method: Method

    static func generates(
        path: String,
        endpoint: OpenAPIEndpoint,
        context: SwiftCodeBuilder.Context
    ) -> [Self] {
        return [
            .init(path: path, method: .GET, endpoint: endpoint, context: context),
            .init(path: path, method: .POST, endpoint: endpoint, context: context),
            .init(path: path, method: .PATCH, endpoint: endpoint, context: context),
            .init(path: path, method: .DELETE, endpoint: endpoint, context: context)
        ].compactMap { $0 }
    }

    init?(
        path: String,
        method: Method,
        endpoint: OpenAPIEndpoint,
        context: SwiftCodeBuilder.Context
    ) {
        func tags<T>(_ method: OpenAPIEndpoint.RequestMethod<T>?) -> Set<String> {
            method?.tags ?? []
        }
        let name = tags(endpoint.get)
            .union(tags(endpoint.post))
            .union(tags(endpoint.patch))
            .union(tags(endpoint.delete))
            .sorted()
            .first
        guard let name = name else { return nil }

        let pathComponents = makePathComponents(from: path)

        func makeFileName() -> String {
            var comps = pathComponents
            while comps.first != name {
                comps.removeFirst()
            }
            let uniqueHash = path.sha1?.prefix(7)
            return "\(comps.joined()).\(method)\(uniqueHash.map { ".\($0)" } ?? "").generated.swift"
        }

        self.path = path
        self.pathComponents = pathComponents
        self.name = name
        self.method = method
        self.endpoint = endpoint
        self.context = context
        self.filePath = "Endpoints/"
            + pathComponents.joined(separator: "/")
            + "/"
            + makeFileName()
    }

    func render() -> String? {
        func _render(_ decl: Decl?) -> String? {
            guard let decl = decl else { return nil }

            return """
            // autogenerated

            // swiftlint:disable all
            import Foundation
            #if canImport(FoundationNetworking)
            import FoundationNetworking
            #endif

            \(SourceFile(decl: ExtensionDecl(
                nameComponents: { $0 + pathComponents },
                body: [decl]
            )).render())

            // swiftlint:enable all

            """.cleaned()
        }

        switch method {
        case .GET:
            return _render(declForGET(endpoint))

        case .POST:
            return _render(declForPOST(endpoint))

        case .PATCH:
            return _render(declForPATCH(endpoint))

        case .DELETE:
            return _render(declForDELETE(endpoint))
        }
    }

    typealias ParameterPack = (
        repr: Repr,
        name: String,
        type: TypeName,
        required: Bool,
        doc: String?
    )

    func declForMethod<T>(_ method: OpenAPIEndpoint.RequestMethod<T>,
                          name: String,
                          parameters: [OpenAPIEndpoint.Parameter],
                          extraArguments: [ParameterPack] = []) -> StructDecl {
        var results: [ParameterPack] = []
        for p in parameters {
            let repr = findRepr(for: p.schema, with: p.name)
            let type = repr.renderType(context: context)
            results.append((repr, p.name, type, p.required ?? false, p.description))
        }
        func declForQueryParameter(_ pack: ParameterPack) -> MemberDecl {
            return MemberDecl(
                access: .public,
                keyword: .var,
                name: pack.name,
                type: "\(pack.type)",
                doc: pack.doc
            )
        }
        func declForInitializerArgument(_ pack: ParameterPack) -> ArgumentDecl {
            return ArgumentDecl(
                name: pack.name,
                type: "\(pack.type)",
                initial: pack.required ? nil : "nil"
            )
        }

        var decl = StructDecl(
            access: .public,
            name: name,
            members: [],
            initializers: [],
            functions: []
        )

        decl.annotations = method.deprecated ?? false ? [.deprecated()] : []
        decl.members.append(
            MemberDecl(
                access: .public,
                keyword: .var,
                name: "path",
                type: "String",
                value: .computed(
                    """
                    "\(path
                        .components(separatedBy: "/")
                        .map { c in
                            c.hasPrefix("{") && c.hasSuffix("}")
                                ? #"\(\#(c.dropFirst().dropLast()))"#
                                : c
                        }
                        .joined(separator: "/"))"
                    """
                )
            )
        )
        decl.members.append(contentsOf: results.map(declForQueryParameter))
        decl.initializers.append(
            InitializerDecl(
                access: .public,
                arguments: (results + extraArguments)
                    .map(declForInitializerArgument),
                body: (results + extraArguments)
                    .map { "self.\($0.name) = \($0.name)" }
                    .joined(separator: "\n")
            )
        )
        buildResponseDecl(into: &decl, method: method, context: context)
        return decl
    }
}

private struct Doc {
    var type: String?
    var prefix: String?
    var status: Int
    var description: String?

    func render() -> String? {
        if type == nil, prefix == nil, description == nil {
            return nil
        }
        return [
            prefix.map { "- \($0)" },
            "**\(status)**\(description != nil ? "," : "")",
            description,
            type.map { "as `\($0)`" }
        ].compactMap { $0 }.joined(separator: " ")
    }
}

private func buildResponseDecl<T>(into baseDecl: inout StructDecl,
                                  method: OpenAPIEndpoint.RequestMethod<T>,
                                  context: SwiftCodeBuilder.Context) {
    var function = FunctionDecl(
        access: .public,
        declModifier: .static,
        name: "response",
        arguments: [
            ArgumentDecl(
                name: "data",
                alt: "from",
                type: "Data"
            ),
            ArgumentDecl(
                name: "urlResponse",
                type: "HTTPURLResponse"
            )
        ],
        parameterModifiers: [.throws],
        returnType: "Response",
        body: ""
    )
    var docs: [Doc] = []
    var body = """
    var jsonDecoder: JSONDecoder {
        let decoder = JSONDecoder()
        return decoder
    }

    switch urlResponse.statusCode {

    """
    func render(success: Bool, contentType: String, content: OpenAPIEndpoint.Response.Content, doc: inout Doc) -> String {
        let repr = findRepr(for: content.schema, with: "")
        let type = repr.renderType(context: context)
        doc.type = "\(type)"
        if success {
            assert(baseDecl.typealiases.isEmpty)
            baseDecl.typealiases.append(
                TypealiasDecl(access: .public, name: "Response", value: "\(type)")
            )
        }
        func renderReturnModifier() -> String {
            success ? "return" : "throw"
        }

        switch contentType {
        case "application/json",
            "application/vnd.apple.diagnostic-logs+json",
            "application/vnd.apple.xcode-metrics+json":
            return """
            \(success ? "return" : "throw") try jsonDecoder.decode(\(type).self, from: data)
            """

        case "text/csv":
            return """
            return String(data: data, encoding: .utf8) ?? ""
            """

        case "gzip", "application/a-gzip":
            assert(success)
            return """
            return data
            """

        default:
            fatalError("unsupported content type \(contentType)")
        }
    }
    for (status, response) in method.responses.sorted(by: { $0.key < $1.key }) {
        let isSuccess = (200..<300).contains(status)
        let content: (contentType: String, content: OpenAPIEndpoint.Response.Content)?

        if response.content?.isEmpty ?? false {
            assertionFailure(String(describing: response.content))
            continue
        } else {
            let found = (response.content?.first(where: { $0.key == "application/json" })
                         ?? response.content?.first)
            content = found.map { ($0.key, $0.value) }
        }

        var doc = Doc(prefix: isSuccess ? "Returns:" : "Throws:",
                      status: status,
                      description: response.description)
        defer {
            docs.append(doc)
        }

        guard let (contentType, content) = content else {
            if isSuccess {
                body += """
                case \(status):
                    return


                """
            }
            continue
        }
        body += """
        case \(status):
        \(render(success: isSuccess, contentType: contentType, content: content, doc: &doc)
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .indent(to: 4))


        """
    }

    body = body.trimmingCharacters(in: .whitespaces) + """
    default:
        throw try jsonDecoder.decode(ErrorResponse.self, from: data)
    }
    """

    if baseDecl.typealiases.isEmpty {
        baseDecl.typealiases.append(TypealiasDecl(access: .public, name: "Response", value: "Void"))
    }

    function.body = body
    function.doc = {
        let docs = docs.compactMap { $0.render() }
        return docs.isEmpty ? nil : docs.joined(separator: "\n")
    }()
    baseDecl.functions.append(function)
}
